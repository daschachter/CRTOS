
CRTOS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000109c  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000474  20000000  0000109c  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a4  20000474  00001510  00020474  2**2
                  ALLOC
  3 .stack        00002000  20000518  000015b4  00020474  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020474  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002049c  2**0
                  CONTENTS, READONLY
  6 .debug_info   000118eb  00000000  00000000  000204f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c6c  00000000  00000000  00031de0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000009a4  00000000  00000000  00032a4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000140  00000000  00000000  000333f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000001f8  00000000  00000000  00033530  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00011acf  00000000  00000000  00033728  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00002c4b  00000000  00000000  000451f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0006ff34  00000000  00000000  00047e42  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000004bc  00000000  00000000  000b7d78  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	18 25 00 20 75 06 00 00 71 06 00 00 71 06 00 00     .%. u...q...q...
	...
      2c:	71 06 00 00 00 00 00 00 00 00 00 00 71 06 00 00     q...........q...
      3c:	69 07 00 00 71 06 00 00 71 06 00 00 71 06 00 00     i...q...q...q...
      4c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
      5c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
      6c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
      7c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
      8c:	71 06 00 00 71 06 00 00 00 00 00 00 00 00 00 00     q...q...........
      9c:	e1 0a 00 00 71 06 00 00 71 06 00 00 71 06 00 00     ....q...q...q...
      ac:	71 06 00 00 00 00 00 00                             q.......

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000474 	.word	0x20000474
      d4:	00000000 	.word	0x00000000
      d8:	0000109c 	.word	0x0000109c

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000478 	.word	0x20000478
     108:	0000109c 	.word	0x0000109c
     10c:	0000109c 	.word	0x0000109c
     110:	00000000 	.word	0x00000000

00000114 <adc_init>:
// Read out the conversion in RESULT
// RESRDY flag when data is a available (set up interrupt using INTENSET?)

#include "crt_adc.h"

void adc_init() {
     114:	b510      	push	{r4, lr}
	/***************Clock Init***************/
	SYSCTRL->OSC8M.bit.PRESC = 0; // no prescalar (is 8 on reset)
     116:	4b48      	ldr	r3, [pc, #288]	; (238 <adc_init+0x124>)
     118:	6a1a      	ldr	r2, [r3, #32]
     11a:	4948      	ldr	r1, [pc, #288]	; (23c <adc_init+0x128>)
     11c:	400a      	ands	r2, r1
     11e:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.reg |= 1 << SYSCTRL_OSC8M_ENABLE_Pos; // enable source
     120:	6a1a      	ldr	r2, [r3, #32]
     122:	2102      	movs	r1, #2
     124:	430a      	orrs	r2, r1
     126:	621a      	str	r2, [r3, #32]
	
	GCLK->GENDIV.bit.ID = 0x0; // select GCLK_GEN[0]
     128:	4b45      	ldr	r3, [pc, #276]	; (240 <adc_init+0x12c>)
     12a:	689a      	ldr	r2, [r3, #8]
     12c:	310d      	adds	r1, #13
     12e:	438a      	bics	r2, r1
     130:	609a      	str	r2, [r3, #8]
	GCLK->GENDIV.bit.DIV = 0; // no prescalar
     132:	689a      	ldr	r2, [r3, #8]
     134:	4843      	ldr	r0, [pc, #268]	; (244 <adc_init+0x130>)
     136:	4002      	ands	r2, r0
     138:	609a      	str	r2, [r3, #8]
	
	GCLK->GENCTRL.bit.ID = 0x0; // select GCLK_GEN[0]
     13a:	685a      	ldr	r2, [r3, #4]
     13c:	438a      	bics	r2, r1
     13e:	605a      	str	r2, [r3, #4]
	GCLK->GENCTRL.reg |= 1 << GCLK_GENCTRL_SRC_OSC8M; // OSC8M source
     140:	685a      	ldr	r2, [r3, #4]
     142:	605a      	str	r2, [r3, #4]
	GCLK->GENCTRL.bit.GENEN = 1; // enable generator
     144:	6859      	ldr	r1, [r3, #4]
     146:	2280      	movs	r2, #128	; 0x80
     148:	0252      	lsls	r2, r2, #9
     14a:	430a      	orrs	r2, r1
     14c:	605a      	str	r2, [r3, #4]
	
	GCLK->CLKCTRL.bit.ID = GCLK_CLKCTRL_ID_ADC; // select GCLK_ADC
     14e:	885a      	ldrh	r2, [r3, #2]
     150:	213f      	movs	r1, #63	; 0x3f
     152:	438a      	bics	r2, r1
     154:	211e      	movs	r1, #30
     156:	430a      	orrs	r2, r1
     158:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK0; // select source GCLK[0] for the ADC
     15a:	885a      	ldrh	r2, [r3, #2]
     15c:	b292      	uxth	r2, r2
     15e:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     160:	8859      	ldrh	r1, [r3, #2]
     162:	2280      	movs	r2, #128	; 0x80
     164:	01d2      	lsls	r2, r2, #7
     166:	430a      	orrs	r2, r1
     168:	805a      	strh	r2, [r3, #2]
	
	/***************Setup Analog Input 1***************/
	PORT->Group[1].DIRCLR.reg = PORT_PB08; // Using PB08
     16a:	4b37      	ldr	r3, [pc, #220]	; (248 <adc_init+0x134>)
     16c:	2180      	movs	r1, #128	; 0x80
     16e:	0049      	lsls	r1, r1, #1
     170:	2284      	movs	r2, #132	; 0x84
     172:	5099      	str	r1, [r3, r2]
	PORT->Group[1].PINCFG[8].reg |= PORT_PINCFG_INEN;
     174:	20c8      	movs	r0, #200	; 0xc8
     176:	5c1a      	ldrb	r2, [r3, r0]
     178:	39fe      	subs	r1, #254	; 0xfe
     17a:	430a      	orrs	r2, r1
     17c:	541a      	strb	r2, [r3, r0]
	PORT->Group[1].PINCFG[8].reg |= PORT_PINCFG_PMUXEN;
     17e:	5c19      	ldrb	r1, [r3, r0]
     180:	2401      	movs	r4, #1
     182:	4321      	orrs	r1, r4
     184:	b2c9      	uxtb	r1, r1
     186:	5419      	strb	r1, [r3, r0]
	PORT->Group[1].PMUX[8 >> 1].reg |= PORT_PMUX_PMUXE_B;
     188:	21b4      	movs	r1, #180	; 0xb4
     18a:	5c5a      	ldrb	r2, [r3, r1]
     18c:	4322      	orrs	r2, r4
     18e:	b2d2      	uxtb	r2, r2
     190:	545a      	strb	r2, [r3, r1]
	
	/***************ADC Init***************/
	
	// Calibration
	uint64_t adc_calib = *(uint64_t*)NVMCTRL_CAL;
     192:	2380      	movs	r3, #128	; 0x80
     194:	041b      	lsls	r3, r3, #16
     196:	681a      	ldr	r2, [r3, #0]
     198:	685b      	ldr	r3, [r3, #4]
	uint16_t adc_linearity = (adc_calib >> 27) & 0xFF;
     19a:	0159      	lsls	r1, r3, #5
     19c:	0ed2      	lsrs	r2, r2, #27
     19e:	430a      	orrs	r2, r1
	uint16_t adc_biascal = (adc_calib >> 35) & 0x07;
	ADC->CALIB.bit.LINEARITY_CAL = adc_linearity;
     1a0:	492a      	ldr	r1, [pc, #168]	; (24c <adc_init+0x138>)
     1a2:	8d08      	ldrh	r0, [r1, #40]	; 0x28
     1a4:	24ff      	movs	r4, #255	; 0xff
     1a6:	4022      	ands	r2, r4
     1a8:	43a0      	bics	r0, r4
     1aa:	4302      	orrs	r2, r0
     1ac:	850a      	strh	r2, [r1, #40]	; 0x28
	uint16_t adc_biascal = (adc_calib >> 35) & 0x07;
     1ae:	069b      	lsls	r3, r3, #26
	ADC->CALIB.bit.BIAS_CAL = adc_biascal;
     1b0:	8d0a      	ldrh	r2, [r1, #40]	; 0x28
     1b2:	0f5b      	lsrs	r3, r3, #29
     1b4:	021b      	lsls	r3, r3, #8
     1b6:	4826      	ldr	r0, [pc, #152]	; (250 <adc_init+0x13c>)
     1b8:	4002      	ands	r2, r0
     1ba:	4313      	orrs	r3, r2
     1bc:	850b      	strh	r3, [r1, #40]	; 0x28
	
	ADC->INPUTCTRL.reg |= (ADC_INPUTCTRL_MUXNEG_GND | ADC_INPUTCTRL_MUXPOS_PIN2); // set analog 1 as input
     1be:	690a      	ldr	r2, [r1, #16]
     1c0:	4b24      	ldr	r3, [pc, #144]	; (254 <adc_init+0x140>)
     1c2:	4313      	orrs	r3, r2
     1c4:	610b      	str	r3, [r1, #16]
	while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     1c6:	000a      	movs	r2, r1
     1c8:	7e53      	ldrb	r3, [r2, #25]
     1ca:	09db      	lsrs	r3, r3, #7
     1cc:	d1fc      	bne.n	1c8 <adc_init+0xb4>
	
	ADC->REFCTRL.reg |= ADC_REFCTRL_REFSEL_INT1V;
     1ce:	4b1f      	ldr	r3, [pc, #124]	; (24c <adc_init+0x138>)
     1d0:	785a      	ldrb	r2, [r3, #1]
     1d2:	b2d2      	uxtb	r2, r2
     1d4:	705a      	strb	r2, [r3, #1]
	
	ADC->CTRLB.reg &= ~ADC_CTRLB_DIFFMODE; // enable free-running, single-ended mode
     1d6:	889a      	ldrh	r2, [r3, #4]
     1d8:	2101      	movs	r1, #1
     1da:	438a      	bics	r2, r1
     1dc:	809a      	strh	r2, [r3, #4]
	while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     1de:	001a      	movs	r2, r3
     1e0:	7e53      	ldrb	r3, [r2, #25]
     1e2:	09db      	lsrs	r3, r3, #7
     1e4:	d1fc      	bne.n	1e0 <adc_init+0xcc>
	
	ADC->CTRLB.reg |= ADC_CTRLB_FREERUN;
     1e6:	4a19      	ldr	r2, [pc, #100]	; (24c <adc_init+0x138>)
     1e8:	8893      	ldrh	r3, [r2, #4]
     1ea:	2104      	movs	r1, #4
     1ec:	430b      	orrs	r3, r1
     1ee:	8093      	strh	r3, [r2, #4]
	while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     1f0:	7e53      	ldrb	r3, [r2, #25]
     1f2:	09db      	lsrs	r3, r3, #7
     1f4:	d1fc      	bne.n	1f0 <adc_init+0xdc>
	
	ADC->CTRLA.bit.ENABLE = 1; // enable ADC
     1f6:	4a15      	ldr	r2, [pc, #84]	; (24c <adc_init+0x138>)
     1f8:	7813      	ldrb	r3, [r2, #0]
     1fa:	2102      	movs	r1, #2
     1fc:	430b      	orrs	r3, r1
     1fe:	7013      	strb	r3, [r2, #0]
	while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     200:	7e53      	ldrb	r3, [r2, #25]
     202:	09db      	lsrs	r3, r3, #7
     204:	d1fc      	bne.n	200 <adc_init+0xec>
	
	ADC->INTENSET.reg |= ADC_INTENSET_RESRDY; // enable interrupt for result being ready
     206:	4a11      	ldr	r2, [pc, #68]	; (24c <adc_init+0x138>)
     208:	7dd3      	ldrb	r3, [r2, #23]
     20a:	2101      	movs	r1, #1
     20c:	430b      	orrs	r3, r1
     20e:	75d3      	strb	r3, [r2, #23]
	while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     210:	7e53      	ldrb	r3, [r2, #25]
     212:	09db      	lsrs	r3, r3, #7
     214:	d1fc      	bne.n	210 <adc_init+0xfc>
	
	ADC->SAMPCTRL.reg |= 0x3F; // set sample length
     216:	4a0d      	ldr	r2, [pc, #52]	; (24c <adc_init+0x138>)
     218:	78d3      	ldrb	r3, [r2, #3]
     21a:	213f      	movs	r1, #63	; 0x3f
     21c:	430b      	orrs	r3, r1
     21e:	70d3      	strb	r3, [r2, #3]
	while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     220:	7e53      	ldrb	r3, [r2, #25]
     222:	09db      	lsrs	r3, r3, #7
     224:	d1fc      	bne.n	220 <adc_init+0x10c>

	ADC->INTFLAG.bit.RESRDY = 0x1; // Clear ready flag
     226:	4a09      	ldr	r2, [pc, #36]	; (24c <adc_init+0x138>)
     228:	7e13      	ldrb	r3, [r2, #24]
     22a:	2101      	movs	r1, #1
     22c:	430b      	orrs	r3, r1
     22e:	7613      	strb	r3, [r2, #24]
	while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     230:	7e53      	ldrb	r3, [r2, #25]
     232:	09db      	lsrs	r3, r3, #7
     234:	d1fc      	bne.n	230 <adc_init+0x11c>
     236:	bd10      	pop	{r4, pc}
     238:	40000800 	.word	0x40000800
     23c:	fffffcff 	.word	0xfffffcff
     240:	40000c00 	.word	0x40000c00
     244:	ff0000ff 	.word	0xff0000ff
     248:	41004400 	.word	0x41004400
     24c:	42004000 	.word	0x42004000
     250:	fffff8ff 	.word	0xfffff8ff
     254:	00001802 	.word	0x00001802

00000258 <sercom_init>:

/**********************
* https://microchipdeveloper.com/32arm:samd21-clock-system-configuration
* Uses OSC8M (i.e 8MHz internal oscillator)
**********************/
void sercom_init( Sercom * channel, uint8_t num ) {
     258:	b530      	push	{r4, r5, lr}
	
	SYSCTRL->OSC8M.bit.PRESC = 0; // no prescalar (is 8 on reset)
     25a:	4b6b      	ldr	r3, [pc, #428]	; (408 <sercom_init+0x1b0>)
     25c:	6a1a      	ldr	r2, [r3, #32]
     25e:	486b      	ldr	r0, [pc, #428]	; (40c <sercom_init+0x1b4>)
     260:	4002      	ands	r2, r0
     262:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.reg |= 1 << SYSCTRL_OSC8M_ENABLE_Pos; // enable source
     264:	6a1a      	ldr	r2, [r3, #32]
     266:	2002      	movs	r0, #2
     268:	4302      	orrs	r2, r0
     26a:	621a      	str	r2, [r3, #32]
	
	GCLK->GENDIV.bit.ID = 0x03; // select GCLK_GEN[3]
     26c:	4b68      	ldr	r3, [pc, #416]	; (410 <sercom_init+0x1b8>)
     26e:	6898      	ldr	r0, [r3, #8]
     270:	250f      	movs	r5, #15
     272:	43a8      	bics	r0, r5
     274:	2403      	movs	r4, #3
     276:	4320      	orrs	r0, r4
     278:	6098      	str	r0, [r3, #8]
	GCLK->GENDIV.bit.DIV = 0; // no prescalar
     27a:	6898      	ldr	r0, [r3, #8]
     27c:	4a65      	ldr	r2, [pc, #404]	; (414 <sercom_init+0x1bc>)
     27e:	4010      	ands	r0, r2
     280:	6098      	str	r0, [r3, #8]
	
	GCLK->GENCTRL.bit.ID = 0x03; // select GCLK_GEN[3]
     282:	685a      	ldr	r2, [r3, #4]
     284:	43aa      	bics	r2, r5
     286:	4322      	orrs	r2, r4
     288:	605a      	str	r2, [r3, #4]
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_SRC_OSC8M; // OSC8M source
     28a:	6858      	ldr	r0, [r3, #4]
     28c:	22c0      	movs	r2, #192	; 0xc0
     28e:	00d2      	lsls	r2, r2, #3
     290:	4302      	orrs	r2, r0
     292:	605a      	str	r2, [r3, #4]
	GCLK->GENCTRL.bit.GENEN = 1; // enable generator
     294:	6858      	ldr	r0, [r3, #4]
     296:	2280      	movs	r2, #128	; 0x80
     298:	0252      	lsls	r2, r2, #9
     29a:	4302      	orrs	r2, r0
     29c:	605a      	str	r2, [r3, #4]
	
	// sercom peripheral channel
	switch(num) {
     29e:	2905      	cmp	r1, #5
     2a0:	d900      	bls.n	2a4 <sercom_init+0x4c>
     2a2:	e093      	b.n	3cc <sercom_init+0x174>
     2a4:	0089      	lsls	r1, r1, #2
     2a6:	4b5c      	ldr	r3, [pc, #368]	; (418 <sercom_init+0x1c0>)
     2a8:	585b      	ldr	r3, [r3, r1]
     2aa:	469f      	mov	pc, r3
		case 0:
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM0_CORE;
     2ac:	4b58      	ldr	r3, [pc, #352]	; (410 <sercom_init+0x1b8>)
     2ae:	2214      	movs	r2, #20
     2b0:	805a      	strh	r2, [r3, #2]
		default:
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM0_CORE;
		break;
	}
	
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK3; // select source GCLK_GEN[3]
     2b2:	885a      	ldrh	r2, [r3, #2]
     2b4:	21c0      	movs	r1, #192	; 0xc0
     2b6:	0089      	lsls	r1, r1, #2
     2b8:	430a      	orrs	r2, r1
     2ba:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     2bc:	8859      	ldrh	r1, [r3, #2]
     2be:	2280      	movs	r2, #128	; 0x80
     2c0:	01d2      	lsls	r2, r2, #7
     2c2:	430a      	orrs	r2, r1
     2c4:	805a      	strh	r2, [r3, #2]
	
	PM->APBCSEL.bit.APBCDIV = 0; // no prescalar
     2c6:	4a55      	ldr	r2, [pc, #340]	; (41c <sercom_init+0x1c4>)
     2c8:	7ad3      	ldrb	r3, [r2, #11]
     2ca:	2107      	movs	r1, #7
     2cc:	438b      	bics	r3, r1
     2ce:	72d3      	strb	r3, [r2, #11]
	switch(num) {
		case 0:
		PM->APBCMASK.bit.SERCOM0_ = 1;
     2d0:	4a52      	ldr	r2, [pc, #328]	; (41c <sercom_init+0x1c4>)
     2d2:	6a13      	ldr	r3, [r2, #32]
     2d4:	2104      	movs	r1, #4
     2d6:	430b      	orrs	r3, r1
     2d8:	6213      	str	r3, [r2, #32]
		break;
		default:
		PM->APBCMASK.bit.SERCOM0_ = 1;
		break;
	}
}
     2da:	bd30      	pop	{r4, r5, pc}
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM1_CORE;
     2dc:	4b4c      	ldr	r3, [pc, #304]	; (410 <sercom_init+0x1b8>)
     2de:	2215      	movs	r2, #21
     2e0:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK3; // select source GCLK_GEN[3]
     2e2:	885a      	ldrh	r2, [r3, #2]
     2e4:	21c0      	movs	r1, #192	; 0xc0
     2e6:	0089      	lsls	r1, r1, #2
     2e8:	430a      	orrs	r2, r1
     2ea:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     2ec:	8859      	ldrh	r1, [r3, #2]
     2ee:	2280      	movs	r2, #128	; 0x80
     2f0:	01d2      	lsls	r2, r2, #7
     2f2:	430a      	orrs	r2, r1
     2f4:	805a      	strh	r2, [r3, #2]
	PM->APBCSEL.bit.APBCDIV = 0; // no prescalar
     2f6:	4a49      	ldr	r2, [pc, #292]	; (41c <sercom_init+0x1c4>)
     2f8:	7ad3      	ldrb	r3, [r2, #11]
     2fa:	2107      	movs	r1, #7
     2fc:	438b      	bics	r3, r1
     2fe:	72d3      	strb	r3, [r2, #11]
		PM->APBCMASK.bit.SERCOM1_ = 1;
     300:	4a46      	ldr	r2, [pc, #280]	; (41c <sercom_init+0x1c4>)
     302:	6a13      	ldr	r3, [r2, #32]
     304:	2108      	movs	r1, #8
     306:	430b      	orrs	r3, r1
     308:	6213      	str	r3, [r2, #32]
		break;
     30a:	e7e6      	b.n	2da <sercom_init+0x82>
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM2_CORE;
     30c:	4b40      	ldr	r3, [pc, #256]	; (410 <sercom_init+0x1b8>)
     30e:	2216      	movs	r2, #22
     310:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK3; // select source GCLK_GEN[3]
     312:	885a      	ldrh	r2, [r3, #2]
     314:	21c0      	movs	r1, #192	; 0xc0
     316:	0089      	lsls	r1, r1, #2
     318:	430a      	orrs	r2, r1
     31a:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     31c:	8859      	ldrh	r1, [r3, #2]
     31e:	2280      	movs	r2, #128	; 0x80
     320:	01d2      	lsls	r2, r2, #7
     322:	430a      	orrs	r2, r1
     324:	805a      	strh	r2, [r3, #2]
	PM->APBCSEL.bit.APBCDIV = 0; // no prescalar
     326:	4a3d      	ldr	r2, [pc, #244]	; (41c <sercom_init+0x1c4>)
     328:	7ad3      	ldrb	r3, [r2, #11]
     32a:	2107      	movs	r1, #7
     32c:	438b      	bics	r3, r1
     32e:	72d3      	strb	r3, [r2, #11]
		PM->APBCMASK.bit.SERCOM2_ = 1;
     330:	4a3a      	ldr	r2, [pc, #232]	; (41c <sercom_init+0x1c4>)
     332:	6a13      	ldr	r3, [r2, #32]
     334:	2110      	movs	r1, #16
     336:	430b      	orrs	r3, r1
     338:	6213      	str	r3, [r2, #32]
		break;
     33a:	e7ce      	b.n	2da <sercom_init+0x82>
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM3_CORE;
     33c:	4b34      	ldr	r3, [pc, #208]	; (410 <sercom_init+0x1b8>)
     33e:	2217      	movs	r2, #23
     340:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK3; // select source GCLK_GEN[3]
     342:	885a      	ldrh	r2, [r3, #2]
     344:	21c0      	movs	r1, #192	; 0xc0
     346:	0089      	lsls	r1, r1, #2
     348:	430a      	orrs	r2, r1
     34a:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     34c:	8859      	ldrh	r1, [r3, #2]
     34e:	2280      	movs	r2, #128	; 0x80
     350:	01d2      	lsls	r2, r2, #7
     352:	430a      	orrs	r2, r1
     354:	805a      	strh	r2, [r3, #2]
	PM->APBCSEL.bit.APBCDIV = 0; // no prescalar
     356:	4a31      	ldr	r2, [pc, #196]	; (41c <sercom_init+0x1c4>)
     358:	7ad3      	ldrb	r3, [r2, #11]
     35a:	2107      	movs	r1, #7
     35c:	438b      	bics	r3, r1
     35e:	72d3      	strb	r3, [r2, #11]
		PM->APBCMASK.bit.SERCOM3_ = 1;
     360:	4a2e      	ldr	r2, [pc, #184]	; (41c <sercom_init+0x1c4>)
     362:	6a13      	ldr	r3, [r2, #32]
     364:	2120      	movs	r1, #32
     366:	430b      	orrs	r3, r1
     368:	6213      	str	r3, [r2, #32]
		break;
     36a:	e7b6      	b.n	2da <sercom_init+0x82>
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM4_CORE;
     36c:	4b28      	ldr	r3, [pc, #160]	; (410 <sercom_init+0x1b8>)
     36e:	2218      	movs	r2, #24
     370:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK3; // select source GCLK_GEN[3]
     372:	885a      	ldrh	r2, [r3, #2]
     374:	21c0      	movs	r1, #192	; 0xc0
     376:	0089      	lsls	r1, r1, #2
     378:	430a      	orrs	r2, r1
     37a:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     37c:	8859      	ldrh	r1, [r3, #2]
     37e:	2280      	movs	r2, #128	; 0x80
     380:	01d2      	lsls	r2, r2, #7
     382:	430a      	orrs	r2, r1
     384:	805a      	strh	r2, [r3, #2]
	PM->APBCSEL.bit.APBCDIV = 0; // no prescalar
     386:	4a25      	ldr	r2, [pc, #148]	; (41c <sercom_init+0x1c4>)
     388:	7ad3      	ldrb	r3, [r2, #11]
     38a:	2107      	movs	r1, #7
     38c:	438b      	bics	r3, r1
     38e:	72d3      	strb	r3, [r2, #11]
		PM->APBCMASK.bit.SERCOM4_ = 1;
     390:	4a22      	ldr	r2, [pc, #136]	; (41c <sercom_init+0x1c4>)
     392:	6a13      	ldr	r3, [r2, #32]
     394:	2140      	movs	r1, #64	; 0x40
     396:	430b      	orrs	r3, r1
     398:	6213      	str	r3, [r2, #32]
		break;
     39a:	e79e      	b.n	2da <sercom_init+0x82>
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM5_CORE;
     39c:	4b1c      	ldr	r3, [pc, #112]	; (410 <sercom_init+0x1b8>)
     39e:	2219      	movs	r2, #25
     3a0:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK3; // select source GCLK_GEN[3]
     3a2:	885a      	ldrh	r2, [r3, #2]
     3a4:	21c0      	movs	r1, #192	; 0xc0
     3a6:	0089      	lsls	r1, r1, #2
     3a8:	430a      	orrs	r2, r1
     3aa:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     3ac:	8859      	ldrh	r1, [r3, #2]
     3ae:	2280      	movs	r2, #128	; 0x80
     3b0:	01d2      	lsls	r2, r2, #7
     3b2:	430a      	orrs	r2, r1
     3b4:	805a      	strh	r2, [r3, #2]
	PM->APBCSEL.bit.APBCDIV = 0; // no prescalar
     3b6:	4a19      	ldr	r2, [pc, #100]	; (41c <sercom_init+0x1c4>)
     3b8:	7ad3      	ldrb	r3, [r2, #11]
     3ba:	2107      	movs	r1, #7
     3bc:	438b      	bics	r3, r1
     3be:	72d3      	strb	r3, [r2, #11]
		PM->APBCMASK.bit.SERCOM5_ = 1;
     3c0:	4a16      	ldr	r2, [pc, #88]	; (41c <sercom_init+0x1c4>)
     3c2:	6a13      	ldr	r3, [r2, #32]
     3c4:	2180      	movs	r1, #128	; 0x80
     3c6:	430b      	orrs	r3, r1
     3c8:	6213      	str	r3, [r2, #32]
		break;
     3ca:	e786      	b.n	2da <sercom_init+0x82>
		GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_SERCOM0_CORE;
     3cc:	4b10      	ldr	r3, [pc, #64]	; (410 <sercom_init+0x1b8>)
     3ce:	2214      	movs	r2, #20
     3d0:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_GEN_GCLK3; // select source GCLK_GEN[3]
     3d2:	885a      	ldrh	r2, [r3, #2]
     3d4:	20c0      	movs	r0, #192	; 0xc0
     3d6:	0080      	lsls	r0, r0, #2
     3d8:	4302      	orrs	r2, r0
     3da:	805a      	strh	r2, [r3, #2]
	GCLK->CLKCTRL.bit.CLKEN = 1; // enable generic clock
     3dc:	8858      	ldrh	r0, [r3, #2]
     3de:	2280      	movs	r2, #128	; 0x80
     3e0:	01d2      	lsls	r2, r2, #7
     3e2:	4302      	orrs	r2, r0
     3e4:	805a      	strh	r2, [r3, #2]
	PM->APBCSEL.bit.APBCDIV = 0; // no prescalar
     3e6:	4a0d      	ldr	r2, [pc, #52]	; (41c <sercom_init+0x1c4>)
     3e8:	7ad3      	ldrb	r3, [r2, #11]
     3ea:	2007      	movs	r0, #7
     3ec:	4383      	bics	r3, r0
     3ee:	72d3      	strb	r3, [r2, #11]
	switch(num) {
     3f0:	2905      	cmp	r1, #5
     3f2:	d905      	bls.n	400 <sercom_init+0x1a8>
		PM->APBCMASK.bit.SERCOM0_ = 1;
     3f4:	4a09      	ldr	r2, [pc, #36]	; (41c <sercom_init+0x1c4>)
     3f6:	6a13      	ldr	r3, [r2, #32]
     3f8:	2104      	movs	r1, #4
     3fa:	430b      	orrs	r3, r1
     3fc:	6213      	str	r3, [r2, #32]
}
     3fe:	e76c      	b.n	2da <sercom_init+0x82>
	switch(num) {
     400:	0089      	lsls	r1, r1, #2
     402:	4b07      	ldr	r3, [pc, #28]	; (420 <sercom_init+0x1c8>)
     404:	585b      	ldr	r3, [r3, r1]
     406:	469f      	mov	pc, r3
     408:	40000800 	.word	0x40000800
     40c:	fffffcff 	.word	0xfffffcff
     410:	40000c00 	.word	0x40000c00
     414:	ff0000ff 	.word	0xff0000ff
     418:	00001044 	.word	0x00001044
     41c:	40000400 	.word	0x40000400
     420:	0000105c 	.word	0x0000105c

00000424 <calculate_baud_value>:
***********************/
uint16_t calculate_baud_value(
const uint32_t baudrate,
const uint32_t peripheral_clock,
uint8_t sample_num)
{
     424:	b5f0      	push	{r4, r5, r6, r7, lr}
     426:	46de      	mov	lr, fp
     428:	4657      	mov	r7, sl
     42a:	464e      	mov	r6, r9
     42c:	4645      	mov	r5, r8
     42e:	b5e0      	push	{r5, r6, r7, lr}
     430:	b085      	sub	sp, #20
     432:	000c      	movs	r4, r1
     434:	0011      	movs	r1, r2
	uint64_t baud_calculated = 0;
	uint64_t temp1;
	
	
	/* Calculate the BAUD value */
	temp1 = ((sample_num * (uint64_t) baudrate) << 32);
     436:	0002      	movs	r2, r0
     438:	2300      	movs	r3, #0
     43a:	0008      	movs	r0, r1
     43c:	2100      	movs	r1, #0
     43e:	4d26      	ldr	r5, [pc, #152]	; (4d8 <calculate_baud_value+0xb4>)
     440:	47a8      	blx	r5
     442:	4683      	mov	fp, r0
	ratio = long_division(temp1, peripheral_clock);
     444:	0026      	movs	r6, r4
     446:	2700      	movs	r7, #0
	uint64_t q = 0, r = 0, bit_shift;
     448:	2300      	movs	r3, #0
     44a:	4699      	mov	r9, r3
     44c:	9301      	str	r3, [sp, #4]
     44e:	2200      	movs	r2, #0
     450:	2300      	movs	r3, #0
	for(i = 63; i >= 0; i--) {
     452:	213f      	movs	r1, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
     454:	2020      	movs	r0, #32
     456:	4682      	mov	sl, r0
     458:	381f      	subs	r0, #31
     45a:	4684      	mov	ip, r0
     45c:	9602      	str	r6, [sp, #8]
     45e:	9703      	str	r7, [sp, #12]
     460:	e012      	b.n	488 <calculate_baud_value+0x64>
     462:	4650      	mov	r0, sl
     464:	1a40      	subs	r0, r0, r1
     466:	4664      	mov	r4, ip
     468:	40c4      	lsrs	r4, r0
     46a:	0020      	movs	r0, r4
     46c:	e013      	b.n	496 <calculate_baud_value+0x72>
			r = r - d;
     46e:	9c02      	ldr	r4, [sp, #8]
     470:	9d03      	ldr	r5, [sp, #12]
     472:	1b12      	subs	r2, r2, r4
     474:	41ab      	sbcs	r3, r5
			q |= bit_shift;
     476:	464c      	mov	r4, r9
     478:	4645      	mov	r5, r8
     47a:	432c      	orrs	r4, r5
     47c:	9d01      	ldr	r5, [sp, #4]
     47e:	4305      	orrs	r5, r0
     480:	46a1      	mov	r9, r4
     482:	9501      	str	r5, [sp, #4]
	for(i = 63; i >= 0; i--) {
     484:	3901      	subs	r1, #1
     486:	d31c      	bcc.n	4c2 <calculate_baud_value+0x9e>
		bit_shift = (uint64_t)1 << i;
     488:	2020      	movs	r0, #32
     48a:	4240      	negs	r0, r0
     48c:	1808      	adds	r0, r1, r0
     48e:	d4e8      	bmi.n	462 <calculate_baud_value+0x3e>
     490:	4664      	mov	r4, ip
     492:	4084      	lsls	r4, r0
     494:	0020      	movs	r0, r4
     496:	4664      	mov	r4, ip
     498:	408c      	lsls	r4, r1
     49a:	46a0      	mov	r8, r4
		r = r << 1;
     49c:	1892      	adds	r2, r2, r2
     49e:	415b      	adcs	r3, r3
     4a0:	0014      	movs	r4, r2
     4a2:	001d      	movs	r5, r3
		if(n & bit_shift) {
     4a4:	465e      	mov	r6, fp
     4a6:	4230      	tst	r0, r6
     4a8:	d003      	beq.n	4b2 <calculate_baud_value+0x8e>
			r |= 0x01;
     4aa:	4666      	mov	r6, ip
     4ac:	4326      	orrs	r6, r4
     4ae:	0032      	movs	r2, r6
     4b0:	002b      	movs	r3, r5
		if(r >= d) {
     4b2:	9c02      	ldr	r4, [sp, #8]
     4b4:	9d03      	ldr	r5, [sp, #12]
     4b6:	429d      	cmp	r5, r3
     4b8:	d8e4      	bhi.n	484 <calculate_baud_value+0x60>
     4ba:	d1d8      	bne.n	46e <calculate_baud_value+0x4a>
     4bc:	4294      	cmp	r4, r2
     4be:	d8e1      	bhi.n	484 <calculate_baud_value+0x60>
     4c0:	e7d5      	b.n	46e <calculate_baud_value+0x4a>
	scale = ((uint64_t)1 << 32) - ratio;
     4c2:	464b      	mov	r3, r9
     4c4:	4258      	negs	r0, r3
	baud_calculated = (65536 * scale) >> 32;
	
	return baud_calculated;
     4c6:	0c00      	lsrs	r0, r0, #16
}
     4c8:	b005      	add	sp, #20
     4ca:	bc3c      	pop	{r2, r3, r4, r5}
     4cc:	4690      	mov	r8, r2
     4ce:	4699      	mov	r9, r3
     4d0:	46a2      	mov	sl, r4
     4d2:	46ab      	mov	fp, r5
     4d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
     4d6:	46c0      	nop			; (mov r8, r8)
     4d8:	00000dbd 	.word	0x00000dbd

000004dc <usart_pin_init>:
/**********************
RX_PINMUX: Pinmux for pin/sercom (e.g. PINMUX_PA11C_SERCOM0_PAD3)
TX_PINMUX: Pinmux for pin/sercom (e.g. PINMUX_PA10C_SERCOM0_PAD2) 
Pinmux definitions are found in samd21g18a.h
***********************/
void usart_pin_init(uint32_t RX_PINMUX, uint32_t TX_PINMUX) {
     4dc:	b5f0      	push	{r4, r5, r6, r7, lr}
     4de:	46de      	mov	lr, fp
     4e0:	4657      	mov	r7, sl
     4e2:	464e      	mov	r6, r9
     4e4:	4645      	mov	r5, r8
     4e6:	b5e0      	push	{r5, r6, r7, lr}
     4e8:	b085      	sub	sp, #20
	// Extract port and pin information
	uint8_t rx_port = (uint8_t)((RX_PINMUX >> 16) / 32);
     4ea:	0c04      	lsrs	r4, r0, #16
	uint8_t tx_port = (uint8_t)((TX_PINMUX >> 16) / 32);
     4ec:	0c0e      	lsrs	r6, r1, #16
	uint8_t rx_port = (uint8_t)((RX_PINMUX >> 16) / 32);
     4ee:	0d42      	lsrs	r2, r0, #21
	uint32_t rx_pin = (RX_PINMUX >> 16) - (rx_port * 32);
     4f0:	23ff      	movs	r3, #255	; 0xff
     4f2:	401a      	ands	r2, r3
     4f4:	9202      	str	r2, [sp, #8]
     4f6:	0155      	lsls	r5, r2, #5
     4f8:	9401      	str	r4, [sp, #4]
     4fa:	1b65      	subs	r5, r4, r5
	uint8_t tx_port = (uint8_t)((TX_PINMUX >> 16) / 32);
     4fc:	0d4c      	lsrs	r4, r1, #21
	uint32_t tx_pin = (TX_PINMUX >> 16) - (tx_port * 32);
     4fe:	4023      	ands	r3, r4
     500:	015c      	lsls	r4, r3, #5
     502:	1b34      	subs	r4, r6, r4
     504:	46a1      	mov	r9, r4
	
	// Configure TX
	PORT->Group[tx_port].DIRSET.reg = (1 << tx_pin);
     506:	2401      	movs	r4, #1
     508:	0027      	movs	r7, r4
     50a:	464a      	mov	r2, r9
     50c:	4097      	lsls	r7, r2
     50e:	01db      	lsls	r3, r3, #7
     510:	4a39      	ldr	r2, [pc, #228]	; (5f8 <usart_pin_init+0x11c>)
     512:	4690      	mov	r8, r2
     514:	4443      	add	r3, r8
     516:	609f      	str	r7, [r3, #8]
	PORT->Group[tx_port].PINCFG[tx_pin].reg |= PORT_PINCFG_INEN;
     518:	469a      	mov	sl, r3
     51a:	44ca      	add	sl, r9
     51c:	2240      	movs	r2, #64	; 0x40
     51e:	4694      	mov	ip, r2
     520:	44e2      	add	sl, ip
     522:	4652      	mov	r2, sl
     524:	7812      	ldrb	r2, [r2, #0]
     526:	4694      	mov	ip, r2
     528:	2202      	movs	r2, #2
     52a:	4690      	mov	r8, r2
     52c:	4667      	mov	r7, ip
     52e:	4642      	mov	r2, r8
     530:	4317      	orrs	r7, r2
     532:	1c3a      	adds	r2, r7, #0
     534:	466f      	mov	r7, sp
     536:	73fa      	strb	r2, [r7, #15]
     538:	7bfa      	ldrb	r2, [r7, #15]
     53a:	4694      	mov	ip, r2
     53c:	4652      	mov	r2, sl
     53e:	4667      	mov	r7, ip
     540:	7017      	strb	r7, [r2, #0]
	PORT->Group[tx_port].PINCFG[tx_pin].reg |= PORT_PINCFG_PMUXEN;
     542:	7812      	ldrb	r2, [r2, #0]
     544:	4693      	mov	fp, r2
     546:	2201      	movs	r2, #1
     548:	4694      	mov	ip, r2
     54a:	465f      	mov	r7, fp
     54c:	4662      	mov	r2, ip
     54e:	4317      	orrs	r7, r2
     550:	1c3a      	adds	r2, r7, #0
     552:	466f      	mov	r7, sp
     554:	73fa      	strb	r2, [r7, #15]
     556:	7bfa      	ldrb	r2, [r7, #15]
     558:	4693      	mov	fp, r2
     55a:	4652      	mov	r2, sl
     55c:	465f      	mov	r7, fp
     55e:	7017      	strb	r7, [r2, #0]
	PORT->Group[tx_port].PMUX[tx_pin >> 1].reg &= ~(0xF << (4 * ((TX_PINMUX >> 16) & 0x01u)));
     560:	464a      	mov	r2, r9
     562:	0852      	lsrs	r2, r2, #1
     564:	4691      	mov	r9, r2
     566:	444b      	add	r3, r9
     568:	3330      	adds	r3, #48	; 0x30
     56a:	781a      	ldrb	r2, [r3, #0]
     56c:	4691      	mov	r9, r2
     56e:	4026      	ands	r6, r4
     570:	00b2      	lsls	r2, r6, #2
     572:	4692      	mov	sl, r2
     574:	260f      	movs	r6, #15
     576:	0037      	movs	r7, r6
     578:	4097      	lsls	r7, r2
     57a:	46bb      	mov	fp, r7
     57c:	464f      	mov	r7, r9
     57e:	465a      	mov	r2, fp
     580:	4397      	bics	r7, r2
     582:	701f      	strb	r7, [r3, #0]
	PORT->Group[tx_port].PMUX[tx_pin >> 1].reg |= (uint8_t)((TX_PINMUX & 0x0000FFFF) << (4 * ((TX_PINMUX >> 16) & 0x01u)));
     584:	781a      	ldrb	r2, [r3, #0]
     586:	4691      	mov	r9, r2
     588:	0409      	lsls	r1, r1, #16
     58a:	0c09      	lsrs	r1, r1, #16
     58c:	4652      	mov	r2, sl
     58e:	4091      	lsls	r1, r2
     590:	464a      	mov	r2, r9
     592:	4311      	orrs	r1, r2
     594:	b2c9      	uxtb	r1, r1
     596:	7019      	strb	r1, [r3, #0]
	// More intuitive approach for PMUX:
	// PORT->Group[tx_port].PMUX[tx_pin >> 1].bit.PMUXE = PORT_PMUX_PMUXE_C_Val;
	
	// Configure RX
	PORT->Group[rx_port].DIRCLR.reg = (1 << rx_pin);
     598:	0021      	movs	r1, r4
     59a:	40a9      	lsls	r1, r5
     59c:	9b02      	ldr	r3, [sp, #8]
     59e:	01db      	lsls	r3, r3, #7
     5a0:	4a15      	ldr	r2, [pc, #84]	; (5f8 <usart_pin_init+0x11c>)
     5a2:	4691      	mov	r9, r2
     5a4:	444b      	add	r3, r9
     5a6:	6059      	str	r1, [r3, #4]
	PORT->Group[rx_port].PINCFG[rx_pin].reg |= PORT_PINCFG_INEN;
     5a8:	195a      	adds	r2, r3, r5
     5aa:	3240      	adds	r2, #64	; 0x40
     5ac:	7811      	ldrb	r1, [r2, #0]
     5ae:	4647      	mov	r7, r8
     5b0:	4339      	orrs	r1, r7
     5b2:	b2c9      	uxtb	r1, r1
     5b4:	7011      	strb	r1, [r2, #0]
	PORT->Group[rx_port].PINCFG[rx_pin].reg &= ~PORT_PINCFG_PULLEN;
     5b6:	7811      	ldrb	r1, [r2, #0]
     5b8:	2704      	movs	r7, #4
     5ba:	43b9      	bics	r1, r7
     5bc:	7011      	strb	r1, [r2, #0]
	PORT->Group[rx_port].PINCFG[rx_pin].reg |= PORT_PINCFG_PMUXEN;
     5be:	7811      	ldrb	r1, [r2, #0]
     5c0:	4667      	mov	r7, ip
     5c2:	4339      	orrs	r1, r7
     5c4:	b2c9      	uxtb	r1, r1
     5c6:	7011      	strb	r1, [r2, #0]
	PORT->Group[rx_port].PMUX[rx_pin >> 1].reg &= ~(0xF << (4 * ((RX_PINMUX >> 16) & 0x01u)));
     5c8:	086d      	lsrs	r5, r5, #1
     5ca:	195b      	adds	r3, r3, r5
     5cc:	3330      	adds	r3, #48	; 0x30
     5ce:	781a      	ldrb	r2, [r3, #0]
     5d0:	9901      	ldr	r1, [sp, #4]
     5d2:	400c      	ands	r4, r1
     5d4:	00a4      	lsls	r4, r4, #2
     5d6:	40a6      	lsls	r6, r4
     5d8:	43b2      	bics	r2, r6
     5da:	701a      	strb	r2, [r3, #0]
	PORT->Group[rx_port].PMUX[rx_pin >> 1].reg |= (uint8_t)((RX_PINMUX & 0x0000FFFF) << (4 * ((RX_PINMUX >> 16) & 0x01u)));
     5dc:	781a      	ldrb	r2, [r3, #0]
     5de:	0400      	lsls	r0, r0, #16
     5e0:	0c00      	lsrs	r0, r0, #16
     5e2:	40a0      	lsls	r0, r4
     5e4:	4310      	orrs	r0, r2
     5e6:	b2c0      	uxtb	r0, r0
     5e8:	7018      	strb	r0, [r3, #0]
	// More intuitive approach for PMUX:
	// PORT->Group[rx_port].PMUX[rx_pin >> 1].bit.PMUXO = PORT_PMUX_PMUXE_C_Val; // NOTE: ...PMUXE... and ...PMUXO... are the same
}
     5ea:	b005      	add	sp, #20
     5ec:	bc3c      	pop	{r2, r3, r4, r5}
     5ee:	4690      	mov	r8, r2
     5f0:	4699      	mov	r9, r3
     5f2:	46a2      	mov	sl, r4
     5f4:	46ab      	mov	fp, r5
     5f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5f8:	41004400 	.word	0x41004400

000005fc <usart_init>:
/**********************
* channel: Sercom being used for USART (e.g. SERCOM3)
* baud: desired baud rate (e.g. 9600)
* initializes USART for 16x oversampling
***********************/
void usart_init(Sercom* channel, uint32_t baud, uint8_t RX_PAD, uint8_t TX_PAD) {
     5fc:	b570      	push	{r4, r5, r6, lr}
     5fe:	0004      	movs	r4, r0
     600:	0008      	movs	r0, r1
	for data reception, PAD[y] will be used as TxD pin by setting TXPO bit as 0,16x over-sampling is selected by setting the 
	SAMPR bit as 0,Generic clock is enabled in all sleep modes by setting RUNSTDBY bit as 1, USART clock mode is selected as 
	USART with internal clock by setting MODE bit into 1.*/
	channel->USART.CTRLA.reg =   SERCOM_USART_CTRLA_DORD          | 
								SERCOM_USART_CTRLA_RXPO(RX_PAD)  |
								SERCOM_USART_CTRLA_TXPO(TX_PAD)  |
     602:	041b      	lsls	r3, r3, #16
     604:	25c0      	movs	r5, #192	; 0xc0
     606:	02ad      	lsls	r5, r5, #10
     608:	402b      	ands	r3, r5
     60a:	0019      	movs	r1, r3
								SERCOM_USART_CTRLA_SAMPR(0x0)    |
								SERCOM_USART_CTRLA_RUNSTDBY      |
     60c:	4b0d      	ldr	r3, [pc, #52]	; (644 <usart_init+0x48>)
     60e:	430b      	orrs	r3, r1
								SERCOM_USART_CTRLA_RXPO(RX_PAD)  |
     610:	0512      	lsls	r2, r2, #20
     612:	21c0      	movs	r1, #192	; 0xc0
     614:	0389      	lsls	r1, r1, #14
     616:	400a      	ands	r2, r1
								SERCOM_USART_CTRLA_RUNSTDBY      |
     618:	431a      	orrs	r2, r3
	channel->USART.CTRLA.reg =   SERCOM_USART_CTRLA_DORD          | 
     61a:	6022      	str	r2, [r4, #0]
								SERCOM_USART_CTRLA_MODE_USART_INT_CLK;
								
	/* baud register value corresponds to the device communication baud rate
	see documentation for arithmetic baud rate formula */
	channel->USART.BAUD.reg = calculate_baud_value(baud, OSC8M_FREQ, 16);
     61c:	2210      	movs	r2, #16
     61e:	490a      	ldr	r1, [pc, #40]	; (648 <usart_init+0x4c>)
     620:	4b0a      	ldr	r3, [pc, #40]	; (64c <usart_init+0x50>)
     622:	4798      	blx	r3
     624:	81a0      	strh	r0, [r4, #12]
	
	/* 8-bits size is selected as character size by setting the bit CHSIZE as 0,
	TXEN bit and RXEN bits are set to enable the transmitter and receiver. */
	channel->USART.CTRLB.reg =  SERCOM_USART_CTRLB_CHSIZE(0x0) |
     626:	6065      	str	r5, [r4, #4]
								SERCOM_USART_CTRLB_TXEN |
								SERCOM_USART_CTRLB_RXEN;
	
	/* synchronization busy */
	while(channel->USART.SYNCBUSY.bit.CTRLB);
     628:	69e3      	ldr	r3, [r4, #28]
     62a:	075b      	lsls	r3, r3, #29
     62c:	d4fc      	bmi.n	628 <usart_init+0x2c>
	/* receive complete interrupt set */
	channel->USART.INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
     62e:	2304      	movs	r3, #4
     630:	75a3      	strb	r3, [r4, #22]
	/* sercom peripheral enabled */
	channel->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     632:	6823      	ldr	r3, [r4, #0]
     634:	2202      	movs	r2, #2
     636:	4313      	orrs	r3, r2
     638:	6023      	str	r3, [r4, #0]
	/* synchronization busy */
	while(channel->USART.SYNCBUSY.reg & SERCOM_USART_SYNCBUSY_ENABLE);
     63a:	69e3      	ldr	r3, [r4, #28]
     63c:	421a      	tst	r2, r3
     63e:	d1fc      	bne.n	63a <usart_init+0x3e>
}
     640:	bd70      	pop	{r4, r5, r6, pc}
     642:	46c0      	nop			; (mov r8, r8)
     644:	40000084 	.word	0x40000084
     648:	007a1200 	.word	0x007a1200
     64c:	00000425 	.word	0x00000425

00000650 <usart_is_busy>:

/**********************
Returns 0 if not busy, 1 otherwise
***********************/
int usart_is_busy(Sercom * channel) {
	return channel->USART.INTFLAG.bit.DRE == 0;
     650:	7e00      	ldrb	r0, [r0, #24]
     652:	07c0      	lsls	r0, r0, #31
     654:	0fc0      	lsrs	r0, r0, #31
     656:	2301      	movs	r3, #1
     658:	4058      	eors	r0, r3
}
     65a:	4770      	bx	lr

0000065c <usart_transmit_byte>:

/**********************
Sends one byte of data
***********************/
void usart_transmit_byte(Sercom * channel, uint8_t send_byte) {
	channel->USART.DATA.reg = send_byte;
     65c:	b289      	uxth	r1, r1
     65e:	8501      	strh	r1, [r0, #40]	; 0x28
}
     660:	4770      	bx	lr

00000662 <usart_data_available>:

/**********************
Returns 0 if not available, 1 otherwise
***********************/
int usart_data_available(Sercom * channel) {
	return  channel->USART.INTFLAG.bit.RXC;
     662:	7e00      	ldrb	r0, [r0, #24]
     664:	0740      	lsls	r0, r0, #29
     666:	0fc0      	lsrs	r0, r0, #31
}
     668:	4770      	bx	lr

0000066a <usart_receive_byte>:

/**********************
Receive one byte of data
***********************/
int usart_receive_byte(Sercom * channel) {
	return channel->USART.DATA.reg;
     66a:	8d00      	ldrh	r0, [r0, #40]	; 0x28
     66c:	b280      	uxth	r0, r0
}
     66e:	4770      	bx	lr

00000670 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     670:	e7fe      	b.n	670 <Dummy_Handler>
	...

00000674 <Reset_Handler>:
{
     674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     676:	4a2a      	ldr	r2, [pc, #168]	; (720 <Reset_Handler+0xac>)
     678:	4b2a      	ldr	r3, [pc, #168]	; (724 <Reset_Handler+0xb0>)
     67a:	429a      	cmp	r2, r3
     67c:	d011      	beq.n	6a2 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     67e:	001a      	movs	r2, r3
     680:	4b29      	ldr	r3, [pc, #164]	; (728 <Reset_Handler+0xb4>)
     682:	429a      	cmp	r2, r3
     684:	d20d      	bcs.n	6a2 <Reset_Handler+0x2e>
     686:	4a29      	ldr	r2, [pc, #164]	; (72c <Reset_Handler+0xb8>)
     688:	3303      	adds	r3, #3
     68a:	1a9b      	subs	r3, r3, r2
     68c:	089b      	lsrs	r3, r3, #2
     68e:	3301      	adds	r3, #1
     690:	009b      	lsls	r3, r3, #2
     692:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     694:	4823      	ldr	r0, [pc, #140]	; (724 <Reset_Handler+0xb0>)
     696:	4922      	ldr	r1, [pc, #136]	; (720 <Reset_Handler+0xac>)
     698:	588c      	ldr	r4, [r1, r2]
     69a:	5084      	str	r4, [r0, r2]
     69c:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     69e:	429a      	cmp	r2, r3
     6a0:	d1fa      	bne.n	698 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     6a2:	4a23      	ldr	r2, [pc, #140]	; (730 <Reset_Handler+0xbc>)
     6a4:	4b23      	ldr	r3, [pc, #140]	; (734 <Reset_Handler+0xc0>)
     6a6:	429a      	cmp	r2, r3
     6a8:	d20a      	bcs.n	6c0 <Reset_Handler+0x4c>
     6aa:	43d3      	mvns	r3, r2
     6ac:	4921      	ldr	r1, [pc, #132]	; (734 <Reset_Handler+0xc0>)
     6ae:	185b      	adds	r3, r3, r1
     6b0:	2103      	movs	r1, #3
     6b2:	438b      	bics	r3, r1
     6b4:	3304      	adds	r3, #4
     6b6:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     6b8:	2100      	movs	r1, #0
     6ba:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     6bc:	4293      	cmp	r3, r2
     6be:	d1fc      	bne.n	6ba <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     6c0:	4a1d      	ldr	r2, [pc, #116]	; (738 <Reset_Handler+0xc4>)
     6c2:	21ff      	movs	r1, #255	; 0xff
     6c4:	4b1d      	ldr	r3, [pc, #116]	; (73c <Reset_Handler+0xc8>)
     6c6:	438b      	bics	r3, r1
     6c8:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     6ca:	39fd      	subs	r1, #253	; 0xfd
     6cc:	2390      	movs	r3, #144	; 0x90
     6ce:	005b      	lsls	r3, r3, #1
     6d0:	4a1b      	ldr	r2, [pc, #108]	; (740 <Reset_Handler+0xcc>)
     6d2:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     6d4:	4a1b      	ldr	r2, [pc, #108]	; (744 <Reset_Handler+0xd0>)
     6d6:	78d3      	ldrb	r3, [r2, #3]
     6d8:	2503      	movs	r5, #3
     6da:	43ab      	bics	r3, r5
     6dc:	2402      	movs	r4, #2
     6de:	4323      	orrs	r3, r4
     6e0:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     6e2:	78d3      	ldrb	r3, [r2, #3]
     6e4:	270c      	movs	r7, #12
     6e6:	43bb      	bics	r3, r7
     6e8:	2608      	movs	r6, #8
     6ea:	4333      	orrs	r3, r6
     6ec:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     6ee:	4b16      	ldr	r3, [pc, #88]	; (748 <Reset_Handler+0xd4>)
     6f0:	7b98      	ldrb	r0, [r3, #14]
     6f2:	2230      	movs	r2, #48	; 0x30
     6f4:	4390      	bics	r0, r2
     6f6:	2220      	movs	r2, #32
     6f8:	4310      	orrs	r0, r2
     6fa:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     6fc:	7b99      	ldrb	r1, [r3, #14]
     6fe:	43b9      	bics	r1, r7
     700:	4331      	orrs	r1, r6
     702:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     704:	7b9a      	ldrb	r2, [r3, #14]
     706:	43aa      	bics	r2, r5
     708:	4322      	orrs	r2, r4
     70a:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     70c:	4a0f      	ldr	r2, [pc, #60]	; (74c <Reset_Handler+0xd8>)
     70e:	6853      	ldr	r3, [r2, #4]
     710:	2180      	movs	r1, #128	; 0x80
     712:	430b      	orrs	r3, r1
     714:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     716:	4b0e      	ldr	r3, [pc, #56]	; (750 <Reset_Handler+0xdc>)
     718:	4798      	blx	r3
        main();
     71a:	4b0e      	ldr	r3, [pc, #56]	; (754 <Reset_Handler+0xe0>)
     71c:	4798      	blx	r3
     71e:	e7fe      	b.n	71e <Reset_Handler+0xaa>
     720:	0000109c 	.word	0x0000109c
     724:	20000000 	.word	0x20000000
     728:	20000474 	.word	0x20000474
     72c:	20000004 	.word	0x20000004
     730:	20000474 	.word	0x20000474
     734:	20000518 	.word	0x20000518
     738:	e000ed00 	.word	0xe000ed00
     73c:	00000000 	.word	0x00000000
     740:	41007000 	.word	0x41007000
     744:	41005000 	.word	0x41005000
     748:	41004800 	.word	0x41004800
     74c:	41004000 	.word	0x41004000
     750:	00000e11 	.word	0x00000e11
     754:	00000b19 	.word	0x00000b19

00000758 <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
     758:	4a01      	ldr	r2, [pc, #4]	; (760 <SystemInit+0x8>)
     75a:	4b02      	ldr	r3, [pc, #8]	; (764 <SystemInit+0xc>)
     75c:	601a      	str	r2, [r3, #0]
        return;
}
     75e:	4770      	bx	lr
     760:	000f4240 	.word	0x000f4240
     764:	20000000 	.word	0x20000000

00000768 <SysTick_Handler>:
volatile unsigned int ul_tickcount ;

/* Interupt handler for Systick */
void SysTick_Handler() {
	
	ul_tickcount++ ;
     768:	4b04      	ldr	r3, [pc, #16]	; (77c <SysTick_Handler+0x14>)
     76a:	681a      	ldr	r2, [r3, #0]
     76c:	3201      	adds	r2, #1
     76e:	601a      	str	r2, [r3, #0]
	time_tick_millsec++ ;
     770:	4903      	ldr	r1, [pc, #12]	; (780 <SysTick_Handler+0x18>)
     772:	680a      	ldr	r2, [r1, #0]
     774:	3201      	adds	r2, #1
     776:	600a      	str	r2, [r1, #0]
	
	if (ul_tickcount % 1000 == 0){ // Update every 1000
     778:	681b      	ldr	r3, [r3, #0]
		//PORT->Group[0].OUTTGL.reg = PORT_PA17;
	}

}
     77a:	4770      	bx	lr
     77c:	200004b0 	.word	0x200004b0
     780:	200004ac 	.word	0x200004ac

00000784 <PT_setup>:

/* Protothreads setup function */
void PT_setup (void){
     784:	b510      	push	{r4, lr}
	
	//Configure the device to run on the SAMD

	PORT->Group[0].DIRSET.reg = PORT_PA17; // Make PA17 an output
     786:	4b0b      	ldr	r3, [pc, #44]	; (7b4 <PT_setup+0x30>)
     788:	2280      	movs	r2, #128	; 0x80
     78a:	0292      	lsls	r2, r2, #10
     78c:	609a      	str	r2, [r3, #8]
	PORT->Group[0].OUTSET.reg = PORT_PA17; // Set output level
     78e:	619a      	str	r2, [r3, #24]
	
	SysTick->CTRL = 0;     // Disable SysTick
     790:	4a09      	ldr	r2, [pc, #36]	; (7b8 <PT_setup+0x34>)
     792:	2000      	movs	r0, #0
     794:	6010      	str	r0, [r2, #0]
	SysTick->LOAD = 47999UL; // Set reload to 1ms (999)
     796:	4b09      	ldr	r3, [pc, #36]	; (7bc <PT_setup+0x38>)
     798:	6053      	str	r3, [r2, #4]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
     79a:	4c09      	ldr	r4, [pc, #36]	; (7c0 <PT_setup+0x3c>)
     79c:	6a23      	ldr	r3, [r4, #32]
     79e:	021b      	lsls	r3, r3, #8
     7a0:	0a1b      	lsrs	r3, r3, #8
     7a2:	21c0      	movs	r1, #192	; 0xc0
     7a4:	0609      	lsls	r1, r1, #24
     7a6:	430b      	orrs	r3, r1
     7a8:	6223      	str	r3, [r4, #32]
	
	NVIC_SetPriority(SysTick_IRQn, 3); // SysTick is low priority
	
	SysTick->VAL = 0;				   // Clear Value 
     7aa:	6090      	str	r0, [r2, #8]
	SysTick->CTRL = 0x00000007;		   // Enable SysTick, Enable Exceptions, Use CPU CLK
     7ac:	2307      	movs	r3, #7
     7ae:	6013      	str	r3, [r2, #0]
	
	NVIC_EnableIRQ(SysTick_IRQn);      // Enable Interrupts
}
     7b0:	bd10      	pop	{r4, pc}
     7b2:	46c0      	nop			; (mov r8, r8)
     7b4:	41004400 	.word	0x41004400
     7b8:	e000e010 	.word	0xe000e010
     7bc:	0000bb7f 	.word	0x0000bb7f
     7c0:	e000ed00 	.word	0xe000ed00

000007c4 <CLK_setup>:

	/* ----------------------------------------------------------------------------------------------
	* 1) Set Flash wait states for 48 MHz (per Table 37-40 in data sheet)
	*/
	
	NVMCTRL->CTRLB.bit.RWS = 1;		/* 1 wait state required @ 3.3V & 48MHz */
     7c4:	4a34      	ldr	r2, [pc, #208]	; (898 <CLK_setup+0xd4>)
     7c6:	6853      	ldr	r3, [r2, #4]
     7c8:	211e      	movs	r1, #30
     7ca:	438b      	bics	r3, r1
     7cc:	391c      	subs	r1, #28
     7ce:	430b      	orrs	r3, r1
     7d0:	6053      	str	r3, [r2, #4]
		.bit.AAMPEN = 0,		/* Disable automatic amplitude control */
		.bit.EN32K = 1,			/* 32kHz output is disabled */
		.bit.XTALEN = 1			/* Crystal connected to XIN32/XOUT32 */
	};
	// Write these settings
	SYSCTRL->XOSC32K.reg = sysctrl_xosc32k.reg;
     7d2:	4b32      	ldr	r3, [pc, #200]	; (89c <CLK_setup+0xd8>)
     7d4:	2283      	movs	r2, #131	; 0x83
     7d6:	0092      	lsls	r2, r2, #2
     7d8:	829a      	strh	r2, [r3, #20]
	// Enable the Oscillator - Separate step per data sheet recommendation (sec 17.6.3)
	SYSCTRL->XOSC32K.bit.ENABLE = 1;
     7da:	8a9a      	ldrh	r2, [r3, #20]
     7dc:	430a      	orrs	r2, r1
     7de:	829a      	strh	r2, [r3, #20]
	
	// Wait for XOSC32K to stabilize
	while(!SYSCTRL->PCLKSR.bit.XOSC32KRDY);
     7e0:	001a      	movs	r2, r3
     7e2:	68d3      	ldr	r3, [r2, #12]
     7e4:	079b      	lsls	r3, r3, #30
     7e6:	d5fc      	bpl.n	7e2 <CLK_setup+0x1e>
	GCLK_GENDIV_Type gclk1_gendiv = {
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K	/* Apply division factor to Generator 1 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk1_gendiv.reg;
     7e8:	4b2d      	ldr	r3, [pc, #180]	; (8a0 <CLK_setup+0xdc>)
     7ea:	2202      	movs	r2, #2
     7ec:	32ff      	adds	r2, #255	; 0xff
     7ee:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 1 with XOSC32K as source
	GCLK_GENCTRL_Type gclk1_genctrl = {
     7f0:	4a2c      	ldr	r2, [pc, #176]	; (8a4 <CLK_setup+0xe0>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x05,		/* Generator source: XOSC32K output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K			/* Generator ID: 1 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk1_genctrl.reg;
     7f2:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     7f4:	001a      	movs	r2, r3
     7f6:	7853      	ldrb	r3, [r2, #1]
     7f8:	09db      	lsrs	r3, r3, #7
     7fa:	d1fc      	bne.n	7f6 <CLK_setup+0x32>
		.bit.CLKEN = 1,			/* Enable the Generic Clock */
		.bit.GEN = GENERIC_CLOCK_GENERATOR_XOSC32K, 	/* Generic Clock Generator 1 is the source */
		.bit.ID = 0x00			/* Generic Clock Multiplexer 0 (DFLL48M Reference) */
	};
	// Write these settings
	GCLK->CLKCTRL.reg = gclk_clkctrl.reg;
     7fc:	4b28      	ldr	r3, [pc, #160]	; (8a0 <CLK_setup+0xdc>)
     7fe:	2282      	movs	r2, #130	; 0x82
     800:	01d2      	lsls	r2, r2, #7
     802:	805a      	strh	r2, [r3, #2]
	// Enable the DFLL48M in open loop mode. Without this step, attempts to go into closed loop mode at 48 MHz will
	// result in Processor Reset (you'll be at the in the Reset_Handler in startup_samd21.c).
	// PCLKSR.DFLLRDY must be one before writing to the DFLL Control register
	// Note that the DFLLRDY bit represents status of register synchronization - NOT clock stability
	// (see Data Sheet 17.6.14 Synchronization for detail)
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     804:	4a25      	ldr	r2, [pc, #148]	; (89c <CLK_setup+0xd8>)
     806:	68d3      	ldr	r3, [r2, #12]
     808:	06db      	lsls	r3, r3, #27
     80a:	d5fc      	bpl.n	806 <CLK_setup+0x42>
	SYSCTRL->DFLLCTRL.reg = (uint16_t)(SYSCTRL_DFLLCTRL_ENABLE);
     80c:	2202      	movs	r2, #2
     80e:	4b23      	ldr	r3, [pc, #140]	; (89c <CLK_setup+0xd8>)
     810:	849a      	strh	r2, [r3, #36]	; 0x24
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     812:	001a      	movs	r2, r3
     814:	68d3      	ldr	r3, [r2, #12]
     816:	06db      	lsls	r3, r3, #27
     818:	d5fc      	bpl.n	814 <CLK_setup+0x50>
		.bit.CSTEP = 31,		/* Coarse step - use half of the max value (63) */
		.bit.FSTEP = 511,		/* Fine step - use half of the max value (1023) */
		.bit.MUL = 1465			/* Multiplier = MAIN_CLK_FREQ (48MHz) / EXT_32K_CLK_FREQ (32768 Hz) */
	};
	// Write these settings
	SYSCTRL->DFLLMUL.reg = sysctrl_dfllmul.reg;
     81a:	4b20      	ldr	r3, [pc, #128]	; (89c <CLK_setup+0xd8>)
     81c:	4a22      	ldr	r2, [pc, #136]	; (8a8 <CLK_setup+0xe4>)
     81e:	62da      	str	r2, [r3, #44]	; 0x2c
	// Wait for synchronization
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     820:	001a      	movs	r2, r3
     822:	68d3      	ldr	r3, [r2, #12]
     824:	06db      	lsls	r3, r3, #27
     826:	d5fc      	bpl.n	822 <CLK_setup+0x5e>
	
	// To reduce lock time, load factory calibrated values into DFLLVAL (cf. Data Sheet 17.6.7.1)
	// Location of value is defined in Data Sheet Table 10-5. NVM Software Calibration Area Mapping
	
	// Get factory calibrated value for "DFLL48M COARSE CAL" from NVM Software Calibration Area
	tempDFLL48CalibrationCoarse = *(uint32_t*)FUSES_DFLL48M_COARSE_CAL_ADDR;
     828:	4b20      	ldr	r3, [pc, #128]	; (8ac <CLK_setup+0xe8>)
	tempDFLL48CalibrationCoarse &= FUSES_DFLL48M_COARSE_CAL_Msk;
	tempDFLL48CalibrationCoarse = tempDFLL48CalibrationCoarse>>FUSES_DFLL48M_COARSE_CAL_Pos;
	// Write the coarse calibration value
	SYSCTRL->DFLLVAL.bit.COARSE = tempDFLL48CalibrationCoarse;
     82a:	681a      	ldr	r2, [r3, #0]
     82c:	491b      	ldr	r1, [pc, #108]	; (89c <CLK_setup+0xd8>)
     82e:	6a8b      	ldr	r3, [r1, #40]	; 0x28
     830:	0e92      	lsrs	r2, r2, #26
     832:	0292      	lsls	r2, r2, #10
     834:	481e      	ldr	r0, [pc, #120]	; (8b0 <CLK_setup+0xec>)
     836:	4003      	ands	r3, r0
     838:	4313      	orrs	r3, r2
     83a:	628b      	str	r3, [r1, #40]	; 0x28
	// Switch DFLL48M to Closed Loop mode and enable WAITLOCK
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     83c:	000a      	movs	r2, r1
     83e:	68d3      	ldr	r3, [r2, #12]
     840:	06db      	lsls	r3, r3, #27
     842:	d5fc      	bpl.n	83e <CLK_setup+0x7a>
	SYSCTRL->DFLLCTRL.reg |= (uint16_t) (SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_WAITLOCK);
     844:	4a15      	ldr	r2, [pc, #84]	; (89c <CLK_setup+0xd8>)
     846:	8c93      	ldrh	r3, [r2, #36]	; 0x24
     848:	491a      	ldr	r1, [pc, #104]	; (8b4 <CLK_setup+0xf0>)
     84a:	430b      	orrs	r3, r1
     84c:	8493      	strh	r3, [r2, #36]	; 0x24
		.bit.IDC = 1,			/* Generator duty cycle is 50/50 */
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x07,		/* Generator source: DFLL48M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_MAIN			/* Generator ID: 0 */
	};
	GCLK->GENCTRL.reg = gclk_genctrl0.reg;
     84e:	4b14      	ldr	r3, [pc, #80]	; (8a0 <CLK_setup+0xdc>)
     850:	4a19      	ldr	r2, [pc, #100]	; (8b8 <CLK_setup+0xf4>)
     852:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     854:	001a      	movs	r2, r3
     856:	7853      	ldrb	r3, [r2, #1]
     858:	09db      	lsrs	r3, r3, #7
     85a:	d1fc      	bne.n	856 <CLK_setup+0x92>
		.bit.PMUX = 7,			/* Peripheral Function H selected (GCLK_IO[0]) */
		.bit.PMUXEN = 1,		/* Enable peripheral Multiplexer */
		.bit.PINMASK = (uint16_t)(1 << (28-16)) /* Select the pin(s) to be configured */
	};
	// Write these settings
	PORT->Group[0].WRCONFIG.reg = port0_wrconfig.reg;
     85c:	4b17      	ldr	r3, [pc, #92]	; (8bc <CLK_setup+0xf8>)
     85e:	4a18      	ldr	r2, [pc, #96]	; (8c0 <CLK_setup+0xfc>)
     860:	629a      	str	r2, [r3, #40]	; 0x28
	
	/* ----------------------------------------------------------------------------------------------
	* 7) Modify prescaler value of OSC8M to produce 8MHz output
	*/

	SYSCTRL->OSC8M.bit.PRESC = 0;		/* Prescale by 1 */
     862:	4b0e      	ldr	r3, [pc, #56]	; (89c <CLK_setup+0xd8>)
     864:	6a1a      	ldr	r2, [r3, #32]
     866:	4917      	ldr	r1, [pc, #92]	; (8c4 <CLK_setup+0x100>)
     868:	400a      	ands	r2, r1
     86a:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;	/* Oscillator is always on if enabled */
     86c:	6a1a      	ldr	r2, [r3, #32]
     86e:	2180      	movs	r1, #128	; 0x80
     870:	438a      	bics	r2, r1
     872:	621a      	str	r2, [r3, #32]
	GCLK_GENDIV_Type gclk3_gendiv = {
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M		/* Apply division factor to Generator 3 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk3_gendiv.reg;
     874:	4b0a      	ldr	r3, [pc, #40]	; (8a0 <CLK_setup+0xdc>)
     876:	2204      	movs	r2, #4
     878:	32ff      	adds	r2, #255	; 0xff
     87a:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 3 with OSC8M as source
	GCLK_GENCTRL_Type gclk3_genctrl = {
     87c:	4a12      	ldr	r2, [pc, #72]	; (8c8 <CLK_setup+0x104>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x06,		/* Generator source: OSC8M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M			/* Generator ID: 3 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk3_genctrl.reg;
     87e:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     880:	001a      	movs	r2, r3
     882:	7853      	ldrb	r3, [r2, #1]
     884:	09db      	lsrs	r3, r3, #7
     886:	d1fc      	bne.n	882 <CLK_setup+0xbe>
	
	/* ----------------------------------------------------------------------------------------------
	* 9) Set CPU and APBx BUS Clocks to 48MHz
	*/
	PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
     888:	4b10      	ldr	r3, [pc, #64]	; (8cc <CLK_setup+0x108>)
     88a:	2200      	movs	r2, #0
     88c:	721a      	strb	r2, [r3, #8]
	PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
     88e:	725a      	strb	r2, [r3, #9]
	PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
     890:	729a      	strb	r2, [r3, #10]
	PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
     892:	72da      	strb	r2, [r3, #11]
	
} // ClockSysInit48M()
     894:	4770      	bx	lr
     896:	46c0      	nop			; (mov r8, r8)
     898:	41004000 	.word	0x41004000
     89c:	40000800 	.word	0x40000800
     8a0:	40000c00 	.word	0x40000c00
     8a4:	00030501 	.word	0x00030501
     8a8:	7dff05b9 	.word	0x7dff05b9
     8ac:	00806024 	.word	0x00806024
     8b0:	ffff03ff 	.word	0xffff03ff
     8b4:	00000804 	.word	0x00000804
     8b8:	000b0700 	.word	0x000b0700
     8bc:	41004400 	.word	0x41004400
     8c0:	d7011000 	.word	0xd7011000
     8c4:	fffffcff 	.word	0xfffffcff
     8c8:	00030603 	.word	0x00030603
     8cc:	40000400 	.word	0x40000400

000008d0 <PT_get_serial_buffer>:
***********************/
#define MAX_CHARS 64
#define BACKSPACE 0x7f
#define USART_SERIAL_CHANNEL SERCOM0
char PT_term_buffer[MAX_CHARS];
int PT_get_serial_buffer(struct pt *pt) {
     8d0:	b570      	push	{r4, r5, r6, lr}
     8d2:	0004      	movs	r4, r0
	static uint8_t character;
	static int num_char;
	
	// start of input thread
	PT_BEGIN(pt);
     8d4:	2201      	movs	r2, #1
     8d6:	6803      	ldr	r3, [r0, #0]
     8d8:	2b00      	cmp	r3, #0
     8da:	d000      	beq.n	8de <PT_get_serial_buffer+0xe>
     8dc:	469f      	mov	pc, r3
	
	num_char = 0;
     8de:	2200      	movs	r2, #0
     8e0:	4b41      	ldr	r3, [pc, #260]	; (9e8 <PT_get_serial_buffer+0x118>)
     8e2:	605a      	str	r2, [r3, #4]
	// clear buffer
	memset(PT_term_buffer, 0, MAX_CHARS);
     8e4:	3240      	adds	r2, #64	; 0x40
     8e6:	2100      	movs	r1, #0
     8e8:	4840      	ldr	r0, [pc, #256]	; (9ec <PT_get_serial_buffer+0x11c>)
     8ea:	4b41      	ldr	r3, [pc, #260]	; (9f0 <PT_get_serial_buffer+0x120>)
     8ec:	4798      	blx	r3
	
	while(num_char < MAX_CHARS) {
		// get the character
		// yield until there is a valid character so that other
		// threads can execute
		PT_YIELD_UNTIL(pt, usart_data_available(USART_SERIAL_CHANNEL));
     8ee:	4b41      	ldr	r3, [pc, #260]	; (9f4 <PT_get_serial_buffer+0x124>)
     8f0:	6023      	str	r3, [r4, #0]
     8f2:	2301      	movs	r3, #1
     8f4:	e01b      	b.n	92e <PT_get_serial_buffer+0x5e>
     8f6:	4b3f      	ldr	r3, [pc, #252]	; (9f4 <PT_get_serial_buffer+0x124>)
     8f8:	6003      	str	r3, [r0, #0]
     8fa:	2301      	movs	r3, #1
     8fc:	2a00      	cmp	r2, #0
     8fe:	d016      	beq.n	92e <PT_get_serial_buffer+0x5e>
     900:	483d      	ldr	r0, [pc, #244]	; (9f8 <PT_get_serial_buffer+0x128>)
     902:	4b3e      	ldr	r3, [pc, #248]	; (9fc <PT_get_serial_buffer+0x12c>)
     904:	4798      	blx	r3
     906:	2301      	movs	r3, #1
     908:	2800      	cmp	r0, #0
     90a:	d010      	beq.n	92e <PT_get_serial_buffer+0x5e>
		character = usart_receive_byte(USART_SERIAL_CHANNEL);
     90c:	483a      	ldr	r0, [pc, #232]	; (9f8 <PT_get_serial_buffer+0x128>)
     90e:	4b3c      	ldr	r3, [pc, #240]	; (a00 <PT_get_serial_buffer+0x130>)
     910:	4798      	blx	r3
     912:	4b35      	ldr	r3, [pc, #212]	; (9e8 <PT_get_serial_buffer+0x118>)
     914:	7218      	strb	r0, [r3, #8]
		PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     916:	4b3b      	ldr	r3, [pc, #236]	; (a04 <PT_get_serial_buffer+0x134>)
     918:	6023      	str	r3, [r4, #0]
     91a:	2301      	movs	r3, #1
     91c:	e007      	b.n	92e <PT_get_serial_buffer+0x5e>
     91e:	4b39      	ldr	r3, [pc, #228]	; (a04 <PT_get_serial_buffer+0x134>)
     920:	6003      	str	r3, [r0, #0]
     922:	4835      	ldr	r0, [pc, #212]	; (9f8 <PT_get_serial_buffer+0x128>)
     924:	4b38      	ldr	r3, [pc, #224]	; (a08 <PT_get_serial_buffer+0x138>)
     926:	4798      	blx	r3
     928:	2301      	movs	r3, #1
     92a:	2800      	cmp	r0, #0
     92c:	d001      	beq.n	932 <PT_get_serial_buffer+0x62>
		else { PT_term_buffer[num_char++] = character;}
	}
	
	PT_EXIT(pt);
	PT_END(pt);
}
     92e:	0018      	movs	r0, r3
     930:	bd70      	pop	{r4, r5, r6, pc}
		usart_transmit_byte(USART_SERIAL_CHANNEL, character);
     932:	4d2d      	ldr	r5, [pc, #180]	; (9e8 <PT_get_serial_buffer+0x118>)
     934:	7a29      	ldrb	r1, [r5, #8]
     936:	4830      	ldr	r0, [pc, #192]	; (9f8 <PT_get_serial_buffer+0x128>)
     938:	4b34      	ldr	r3, [pc, #208]	; (a0c <PT_get_serial_buffer+0x13c>)
     93a:	4798      	blx	r3
		if(character == '\r') {
     93c:	7a2b      	ldrb	r3, [r5, #8]
     93e:	2b0d      	cmp	r3, #13
     940:	d008      	beq.n	954 <PT_get_serial_buffer+0x84>
		else if(character == BACKSPACE) {
     942:	2b7f      	cmp	r3, #127	; 0x7f
     944:	d04b      	beq.n	9de <PT_get_serial_buffer+0x10e>
		else { PT_term_buffer[num_char++] = character;}
     946:	4928      	ldr	r1, [pc, #160]	; (9e8 <PT_get_serial_buffer+0x118>)
     948:	684a      	ldr	r2, [r1, #4]
     94a:	1c50      	adds	r0, r2, #1
     94c:	6048      	str	r0, [r1, #4]
     94e:	4927      	ldr	r1, [pc, #156]	; (9ec <PT_get_serial_buffer+0x11c>)
     950:	548b      	strb	r3, [r1, r2]
     952:	e037      	b.n	9c4 <PT_get_serial_buffer+0xf4>
			PT_term_buffer[num_char] = 0; // zero terminate the string
     954:	4b24      	ldr	r3, [pc, #144]	; (9e8 <PT_get_serial_buffer+0x118>)
     956:	685b      	ldr	r3, [r3, #4]
     958:	2100      	movs	r1, #0
     95a:	4a24      	ldr	r2, [pc, #144]	; (9ec <PT_get_serial_buffer+0x11c>)
     95c:	54d1      	strb	r1, [r2, r3]
			PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     95e:	4b2c      	ldr	r3, [pc, #176]	; (a10 <PT_get_serial_buffer+0x140>)
     960:	6023      	str	r3, [r4, #0]
     962:	2301      	movs	r3, #1
     964:	e7e3      	b.n	92e <PT_get_serial_buffer+0x5e>
     966:	4b2a      	ldr	r3, [pc, #168]	; (a10 <PT_get_serial_buffer+0x140>)
     968:	6003      	str	r3, [r0, #0]
     96a:	4823      	ldr	r0, [pc, #140]	; (9f8 <PT_get_serial_buffer+0x128>)
     96c:	4b26      	ldr	r3, [pc, #152]	; (a08 <PT_get_serial_buffer+0x138>)
     96e:	4798      	blx	r3
     970:	2301      	movs	r3, #1
     972:	2800      	cmp	r0, #0
     974:	d1db      	bne.n	92e <PT_get_serial_buffer+0x5e>
			usart_transmit_byte(USART_SERIAL_CHANNEL,'\n');
     976:	210a      	movs	r1, #10
     978:	481f      	ldr	r0, [pc, #124]	; (9f8 <PT_get_serial_buffer+0x128>)
     97a:	4b24      	ldr	r3, [pc, #144]	; (a0c <PT_get_serial_buffer+0x13c>)
     97c:	4798      	blx	r3
			break;
     97e:	e026      	b.n	9ce <PT_get_serial_buffer+0xfe>
			PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     980:	4b24      	ldr	r3, [pc, #144]	; (a14 <PT_get_serial_buffer+0x144>)
     982:	6003      	str	r3, [r0, #0]
     984:	481c      	ldr	r0, [pc, #112]	; (9f8 <PT_get_serial_buffer+0x128>)
     986:	4b20      	ldr	r3, [pc, #128]	; (a08 <PT_get_serial_buffer+0x138>)
     988:	4798      	blx	r3
     98a:	2301      	movs	r3, #1
     98c:	2800      	cmp	r0, #0
     98e:	d1ce      	bne.n	92e <PT_get_serial_buffer+0x5e>
			usart_transmit_byte(USART_SERIAL_CHANNEL, ' ');
     990:	2120      	movs	r1, #32
     992:	4819      	ldr	r0, [pc, #100]	; (9f8 <PT_get_serial_buffer+0x128>)
     994:	4b1d      	ldr	r3, [pc, #116]	; (a0c <PT_get_serial_buffer+0x13c>)
     996:	4798      	blx	r3
			PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     998:	4b1f      	ldr	r3, [pc, #124]	; (a18 <PT_get_serial_buffer+0x148>)
     99a:	6023      	str	r3, [r4, #0]
     99c:	2301      	movs	r3, #1
     99e:	e7c6      	b.n	92e <PT_get_serial_buffer+0x5e>
     9a0:	4b1d      	ldr	r3, [pc, #116]	; (a18 <PT_get_serial_buffer+0x148>)
     9a2:	6003      	str	r3, [r0, #0]
     9a4:	4814      	ldr	r0, [pc, #80]	; (9f8 <PT_get_serial_buffer+0x128>)
     9a6:	4b18      	ldr	r3, [pc, #96]	; (a08 <PT_get_serial_buffer+0x138>)
     9a8:	4798      	blx	r3
     9aa:	2301      	movs	r3, #1
     9ac:	2800      	cmp	r0, #0
     9ae:	d1be      	bne.n	92e <PT_get_serial_buffer+0x5e>
			usart_transmit_byte(USART_SERIAL_CHANNEL, BACKSPACE);
     9b0:	217f      	movs	r1, #127	; 0x7f
     9b2:	4811      	ldr	r0, [pc, #68]	; (9f8 <PT_get_serial_buffer+0x128>)
     9b4:	4b15      	ldr	r3, [pc, #84]	; (a0c <PT_get_serial_buffer+0x13c>)
     9b6:	4798      	blx	r3
			num_char--;
     9b8:	4b0b      	ldr	r3, [pc, #44]	; (9e8 <PT_get_serial_buffer+0x118>)
     9ba:	685b      	ldr	r3, [r3, #4]
			if(num_char < 0) { num_char = 0; }
     9bc:	3b01      	subs	r3, #1
     9be:	d40a      	bmi.n	9d6 <PT_get_serial_buffer+0x106>
			num_char--;
     9c0:	4a09      	ldr	r2, [pc, #36]	; (9e8 <PT_get_serial_buffer+0x118>)
     9c2:	6053      	str	r3, [r2, #4]
	while(num_char < MAX_CHARS) {
     9c4:	4b08      	ldr	r3, [pc, #32]	; (9e8 <PT_get_serial_buffer+0x118>)
     9c6:	685b      	ldr	r3, [r3, #4]
     9c8:	2b3f      	cmp	r3, #63	; 0x3f
     9ca:	dc00      	bgt.n	9ce <PT_get_serial_buffer+0xfe>
     9cc:	e78f      	b.n	8ee <PT_get_serial_buffer+0x1e>
	PT_EXIT(pt);
     9ce:	2300      	movs	r3, #0
     9d0:	6023      	str	r3, [r4, #0]
     9d2:	3302      	adds	r3, #2
     9d4:	e7ab      	b.n	92e <PT_get_serial_buffer+0x5e>
			if(num_char < 0) { num_char = 0; }
     9d6:	2200      	movs	r2, #0
     9d8:	4b03      	ldr	r3, [pc, #12]	; (9e8 <PT_get_serial_buffer+0x118>)
     9da:	605a      	str	r2, [r3, #4]
     9dc:	e787      	b.n	8ee <PT_get_serial_buffer+0x1e>
			PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     9de:	4b0d      	ldr	r3, [pc, #52]	; (a14 <PT_get_serial_buffer+0x144>)
     9e0:	6023      	str	r3, [r4, #0]
     9e2:	2301      	movs	r3, #1
     9e4:	e7a3      	b.n	92e <PT_get_serial_buffer+0x5e>
     9e6:	46c0      	nop			; (mov r8, r8)
     9e8:	20000490 	.word	0x20000490
     9ec:	200004b4 	.word	0x200004b4
     9f0:	00000e59 	.word	0x00000e59
     9f4:	000008f6 	.word	0x000008f6
     9f8:	42000800 	.word	0x42000800
     9fc:	00000663 	.word	0x00000663
     a00:	0000066b 	.word	0x0000066b
     a04:	0000091e 	.word	0x0000091e
     a08:	00000651 	.word	0x00000651
     a0c:	0000065d 	.word	0x0000065d
     a10:	00000966 	.word	0x00000966
     a14:	00000980 	.word	0x00000980
     a18:	000009a0 	.word	0x000009a0

00000a1c <PT_put_serial_buffer>:
/**********************
* send a string to the UART
***********************/
volatile char PT_send_buffer[MAX_CHARS] = "ack\r\n";
int num_send_chars;
int PT_put_serial_buffer(struct pt *pt) {
     a1c:	b570      	push	{r4, r5, r6, lr}
     a1e:	0004      	movs	r4, r0
	PT_BEGIN(pt);
     a20:	2301      	movs	r3, #1
     a22:	6802      	ldr	r2, [r0, #0]
     a24:	2a00      	cmp	r2, #0
     a26:	d005      	beq.n	a34 <PT_put_serial_buffer+0x18>
	num_send_chars = 0;
	while(PT_send_buffer[num_send_chars] != 0) {
		PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     a28:	4a12      	ldr	r2, [pc, #72]	; (a74 <PT_put_serial_buffer+0x58>)
     a2a:	6022      	str	r2, [r4, #0]
     a2c:	2001      	movs	r0, #1
     a2e:	2b00      	cmp	r3, #0
     a30:	d10c      	bne.n	a4c <PT_put_serial_buffer+0x30>
		num_send_chars++;
	}
	
	PT_EXIT(pt);
	PT_END(pt);
     a32:	bd70      	pop	{r4, r5, r6, pc}
	num_send_chars = 0;
     a34:	4b10      	ldr	r3, [pc, #64]	; (a78 <PT_put_serial_buffer+0x5c>)
     a36:	601a      	str	r2, [r3, #0]
	while(PT_send_buffer[num_send_chars] != 0) {
     a38:	4b0f      	ldr	r3, [pc, #60]	; (a78 <PT_put_serial_buffer+0x5c>)
     a3a:	681b      	ldr	r3, [r3, #0]
     a3c:	4a0f      	ldr	r2, [pc, #60]	; (a7c <PT_put_serial_buffer+0x60>)
     a3e:	5cd2      	ldrb	r2, [r2, r3]
		PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     a40:	2300      	movs	r3, #0
	while(PT_send_buffer[num_send_chars] != 0) {
     a42:	2a00      	cmp	r2, #0
     a44:	d1f0      	bne.n	a28 <PT_put_serial_buffer+0xc>
	PT_EXIT(pt);
     a46:	6023      	str	r3, [r4, #0]
     a48:	2002      	movs	r0, #2
     a4a:	e7f2      	b.n	a32 <PT_put_serial_buffer+0x16>
		PT_YIELD_UNTIL(pt, !usart_is_busy(USART_SERIAL_CHANNEL));
     a4c:	480c      	ldr	r0, [pc, #48]	; (a80 <PT_put_serial_buffer+0x64>)
     a4e:	4b0d      	ldr	r3, [pc, #52]	; (a84 <PT_put_serial_buffer+0x68>)
     a50:	4798      	blx	r3
     a52:	0003      	movs	r3, r0
     a54:	2001      	movs	r0, #1
     a56:	2b00      	cmp	r3, #0
     a58:	d1eb      	bne.n	a32 <PT_put_serial_buffer+0x16>
		usart_transmit_byte(USART_SERIAL_CHANNEL, PT_send_buffer[num_send_chars]);
     a5a:	4d07      	ldr	r5, [pc, #28]	; (a78 <PT_put_serial_buffer+0x5c>)
     a5c:	4b07      	ldr	r3, [pc, #28]	; (a7c <PT_put_serial_buffer+0x60>)
     a5e:	682a      	ldr	r2, [r5, #0]
     a60:	5c99      	ldrb	r1, [r3, r2]
     a62:	b2c9      	uxtb	r1, r1
     a64:	4806      	ldr	r0, [pc, #24]	; (a80 <PT_put_serial_buffer+0x64>)
     a66:	4b08      	ldr	r3, [pc, #32]	; (a88 <PT_put_serial_buffer+0x6c>)
     a68:	4798      	blx	r3
		num_send_chars++;
     a6a:	682b      	ldr	r3, [r5, #0]
     a6c:	3301      	adds	r3, #1
     a6e:	602b      	str	r3, [r5, #0]
     a70:	e7e2      	b.n	a38 <PT_put_serial_buffer+0x1c>
     a72:	46c0      	nop			; (mov r8, r8)
     a74:	00000a28 	.word	0x00000a28
     a78:	200004a8 	.word	0x200004a8
     a7c:	20000004 	.word	0x20000004
     a80:	42000800 	.word	0x42000800
     a84:	00000651 	.word	0x00000651
     a88:	0000065d 	.word	0x0000065d

00000a8c <write_int_to_transmit>:

static struct pt pt_getserbuff;
static struct pt pt_putserbuff;


void write_int_to_transmit(int16_t var) {
     a8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     a8e:	46ce      	mov	lr, r9
     a90:	4647      	mov	r7, r8
     a92:	b580      	push	{r7, lr}
     a94:	0004      	movs	r4, r0
	int counter = 4;
	PT_send_buffer[counter + 1] = '\r';
     a96:	4b0f      	ldr	r3, [pc, #60]	; (ad4 <write_int_to_transmit+0x48>)
     a98:	220d      	movs	r2, #13
     a9a:	715a      	strb	r2, [r3, #5]
	PT_send_buffer[counter + 2] = '\n';
     a9c:	3a03      	subs	r2, #3
     a9e:	719a      	strb	r2, [r3, #6]
	int counter = 4;
     aa0:	2504      	movs	r5, #4
	while(counter >= 0) {
		PT_send_buffer[counter--] = (var % 10) + 48;
     aa2:	4b0d      	ldr	r3, [pc, #52]	; (ad8 <write_int_to_transmit+0x4c>)
     aa4:	4699      	mov	r9, r3
     aa6:	4b0b      	ldr	r3, [pc, #44]	; (ad4 <write_int_to_transmit+0x48>)
     aa8:	4698      	mov	r8, r3

		var = var / 10;
     aaa:	4f0c      	ldr	r7, [pc, #48]	; (adc <write_int_to_transmit+0x50>)
		PT_send_buffer[counter--] = (var % 10) + 48;
     aac:	1e6e      	subs	r6, r5, #1
     aae:	210a      	movs	r1, #10
     ab0:	0020      	movs	r0, r4
     ab2:	47c8      	blx	r9
     ab4:	3130      	adds	r1, #48	; 0x30
     ab6:	b2c9      	uxtb	r1, r1
     ab8:	4643      	mov	r3, r8
     aba:	5559      	strb	r1, [r3, r5]
		var = var / 10;
     abc:	210a      	movs	r1, #10
     abe:	0020      	movs	r0, r4
     ac0:	47b8      	blx	r7
     ac2:	b204      	sxth	r4, r0
		PT_send_buffer[counter--] = (var % 10) + 48;
     ac4:	0035      	movs	r5, r6
	while(counter >= 0) {
     ac6:	1c73      	adds	r3, r6, #1
     ac8:	d1f0      	bne.n	aac <write_int_to_transmit+0x20>
	}
}
     aca:	bc0c      	pop	{r2, r3}
     acc:	4690      	mov	r8, r2
     ace:	4699      	mov	r9, r3
     ad0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     ad2:	46c0      	nop			; (mov r8, r8)
     ad4:	20000004 	.word	0x20000004
     ad8:	00000db1 	.word	0x00000db1
     adc:	00000be5 	.word	0x00000be5

00000ae0 <ADC_Handler>:

void ADC_Handler(void) {
     ae0:	b510      	push	{r4, lr}
	if(ADC->INTFLAG.bit.RESRDY) {
     ae2:	4b0a      	ldr	r3, [pc, #40]	; (b0c <ADC_Handler+0x2c>)
     ae4:	7e1b      	ldrb	r3, [r3, #24]
     ae6:	07db      	lsls	r3, r3, #31
     ae8:	d50e      	bpl.n	b08 <ADC_Handler+0x28>
		PORT->Group[0].OUTTGL.reg |= PORT_PA17;
     aea:	4a09      	ldr	r2, [pc, #36]	; (b10 <ADC_Handler+0x30>)
     aec:	69d1      	ldr	r1, [r2, #28]
     aee:	2380      	movs	r3, #128	; 0x80
     af0:	029b      	lsls	r3, r3, #10
     af2:	430b      	orrs	r3, r1
     af4:	61d3      	str	r3, [r2, #28]
		int16_t result = ADC->RESULT.reg;
     af6:	4b05      	ldr	r3, [pc, #20]	; (b0c <ADC_Handler+0x2c>)
     af8:	8b58      	ldrh	r0, [r3, #26]
     afa:	b200      	sxth	r0, r0
		while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     afc:	001a      	movs	r2, r3
     afe:	7e53      	ldrb	r3, [r2, #25]
     b00:	09db      	lsrs	r3, r3, #7
     b02:	d1fc      	bne.n	afe <ADC_Handler+0x1e>
		
		write_int_to_transmit(result);
     b04:	4b03      	ldr	r3, [pc, #12]	; (b14 <ADC_Handler+0x34>)
     b06:	4798      	blx	r3
	}
}
     b08:	bd10      	pop	{r4, pc}
     b0a:	46c0      	nop			; (mov r8, r8)
     b0c:	42004000 	.word	0x42004000
     b10:	41004400 	.word	0x41004400
     b14:	00000a8d 	.word	0x00000a8d

00000b18 <main>:

int main(void) {
     b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SystemInit(); CLK_setup();
     b1a:	4b22      	ldr	r3, [pc, #136]	; (ba4 <main+0x8c>)
     b1c:	4798      	blx	r3
     b1e:	4b22      	ldr	r3, [pc, #136]	; (ba8 <main+0x90>)
     b20:	4798      	blx	r3
	
	sercom_init(SERCOM0, 0);
     b22:	4c22      	ldr	r4, [pc, #136]	; (bac <main+0x94>)
     b24:	2100      	movs	r1, #0
     b26:	0020      	movs	r0, r4
     b28:	4b21      	ldr	r3, [pc, #132]	; (bb0 <main+0x98>)
     b2a:	4798      	blx	r3
	usart_pin_init(PINMUX_PA11C_SERCOM0_PAD3, PINMUX_PA10C_SERCOM0_PAD2);
     b2c:	4921      	ldr	r1, [pc, #132]	; (bb4 <main+0x9c>)
     b2e:	4822      	ldr	r0, [pc, #136]	; (bb8 <main+0xa0>)
     b30:	4b22      	ldr	r3, [pc, #136]	; (bbc <main+0xa4>)
     b32:	4798      	blx	r3
	usart_init(SERCOM0, 9600, 0x3, 0x1);
     b34:	2301      	movs	r3, #1
     b36:	2203      	movs	r2, #3
     b38:	2196      	movs	r1, #150	; 0x96
     b3a:	0189      	lsls	r1, r1, #6
     b3c:	0020      	movs	r0, r4
     b3e:	4c20      	ldr	r4, [pc, #128]	; (bc0 <main+0xa8>)
     b40:	47a0      	blx	r4
	
	// Configure LED
	PORT->Group[0].DIRSET.reg |= PORT_PA17;
     b42:	4b20      	ldr	r3, [pc, #128]	; (bc4 <main+0xac>)
     b44:	6899      	ldr	r1, [r3, #8]
     b46:	2280      	movs	r2, #128	; 0x80
     b48:	0292      	lsls	r2, r2, #10
     b4a:	4311      	orrs	r1, r2
     b4c:	6099      	str	r1, [r3, #8]
	PORT->Group[0].OUTSET.reg |= PORT_PA17;
     b4e:	6999      	ldr	r1, [r3, #24]
     b50:	430a      	orrs	r2, r1
     b52:	619a      	str	r2, [r3, #24]
	
	//NVIC_EnableIRQ(SERCOM0_IRQn);
	
	PT_setup();
     b54:	4b1c      	ldr	r3, [pc, #112]	; (bc8 <main+0xb0>)
     b56:	4798      	blx	r3
	PT_INIT(&pt_getserbuff);
     b58:	4b1c      	ldr	r3, [pc, #112]	; (bcc <main+0xb4>)
     b5a:	2200      	movs	r2, #0
     b5c:	60da      	str	r2, [r3, #12]
	PT_INIT(&pt_putserbuff);
     b5e:	611a      	str	r2, [r3, #16]
	
	//NVIC_EnableIRQ(ADC_IRQn);
	adc_init();
     b60:	4b1b      	ldr	r3, [pc, #108]	; (bd0 <main+0xb8>)
     b62:	4798      	blx	r3
	
	while(1) {
		if(!PT_SCHEDULE(PT_get_serial_buffer(&pt_getserbuff))) {
     b64:	4d19      	ldr	r5, [pc, #100]	; (bcc <main+0xb4>)
     b66:	350c      	adds	r5, #12
			//ADC->SWTRIG.bit.START = 1;
			//while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
			
			
			while(ADC->INTFLAG.bit.RESRDY == 0);
     b68:	4e1a      	ldr	r6, [pc, #104]	; (bd4 <main+0xbc>)
			int16_t result = ADC->RESULT.reg;
			while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
					
			write_int_to_transmit(result);
			
			while(PT_put_serial_buffer(&pt_putserbuff) == PT_YIELDED);
     b6a:	4c18      	ldr	r4, [pc, #96]	; (bcc <main+0xb4>)
     b6c:	3410      	adds	r4, #16
		if(!PT_SCHEDULE(PT_get_serial_buffer(&pt_getserbuff))) {
     b6e:	4f1a      	ldr	r7, [pc, #104]	; (bd8 <main+0xc0>)
     b70:	0028      	movs	r0, r5
     b72:	47b8      	blx	r7
     b74:	2801      	cmp	r0, #1
     b76:	ddfb      	ble.n	b70 <main+0x58>
			while(ADC->INTFLAG.bit.RESRDY == 0);
     b78:	7e33      	ldrb	r3, [r6, #24]
     b7a:	07db      	lsls	r3, r3, #31
     b7c:	d5fc      	bpl.n	b78 <main+0x60>
			PORT->Group[0].OUTTGL.reg |= PORT_PA17;
     b7e:	4a11      	ldr	r2, [pc, #68]	; (bc4 <main+0xac>)
     b80:	69d1      	ldr	r1, [r2, #28]
     b82:	2380      	movs	r3, #128	; 0x80
     b84:	029b      	lsls	r3, r3, #10
     b86:	430b      	orrs	r3, r1
     b88:	61d3      	str	r3, [r2, #28]
			int16_t result = ADC->RESULT.reg;
     b8a:	8b70      	ldrh	r0, [r6, #26]
     b8c:	b200      	sxth	r0, r0
			while(ADC->STATUS.bit.SYNCBUSY); // wait for synchronization
     b8e:	7e73      	ldrb	r3, [r6, #25]
     b90:	09db      	lsrs	r3, r3, #7
     b92:	d1fc      	bne.n	b8e <main+0x76>
			write_int_to_transmit(result);
     b94:	4b11      	ldr	r3, [pc, #68]	; (bdc <main+0xc4>)
     b96:	4798      	blx	r3
			while(PT_put_serial_buffer(&pt_putserbuff) == PT_YIELDED);
     b98:	4f11      	ldr	r7, [pc, #68]	; (be0 <main+0xc8>)
     b9a:	0020      	movs	r0, r4
     b9c:	47b8      	blx	r7
     b9e:	2801      	cmp	r0, #1
     ba0:	d0fb      	beq.n	b9a <main+0x82>
     ba2:	e7e4      	b.n	b6e <main+0x56>
     ba4:	00000759 	.word	0x00000759
     ba8:	000007c5 	.word	0x000007c5
     bac:	42000800 	.word	0x42000800
     bb0:	00000259 	.word	0x00000259
     bb4:	000a0002 	.word	0x000a0002
     bb8:	000b0002 	.word	0x000b0002
     bbc:	000004dd 	.word	0x000004dd
     bc0:	000005fd 	.word	0x000005fd
     bc4:	41004400 	.word	0x41004400
     bc8:	00000785 	.word	0x00000785
     bcc:	20000490 	.word	0x20000490
     bd0:	00000115 	.word	0x00000115
     bd4:	42004000 	.word	0x42004000
     bd8:	000008d1 	.word	0x000008d1
     bdc:	00000a8d 	.word	0x00000a8d
     be0:	00000a1d 	.word	0x00000a1d

00000be4 <__divsi3>:
     be4:	4603      	mov	r3, r0
     be6:	430b      	orrs	r3, r1
     be8:	d47f      	bmi.n	cea <__divsi3+0x106>
     bea:	2200      	movs	r2, #0
     bec:	0843      	lsrs	r3, r0, #1
     bee:	428b      	cmp	r3, r1
     bf0:	d374      	bcc.n	cdc <__divsi3+0xf8>
     bf2:	0903      	lsrs	r3, r0, #4
     bf4:	428b      	cmp	r3, r1
     bf6:	d35f      	bcc.n	cb8 <__divsi3+0xd4>
     bf8:	0a03      	lsrs	r3, r0, #8
     bfa:	428b      	cmp	r3, r1
     bfc:	d344      	bcc.n	c88 <__divsi3+0xa4>
     bfe:	0b03      	lsrs	r3, r0, #12
     c00:	428b      	cmp	r3, r1
     c02:	d328      	bcc.n	c56 <__divsi3+0x72>
     c04:	0c03      	lsrs	r3, r0, #16
     c06:	428b      	cmp	r3, r1
     c08:	d30d      	bcc.n	c26 <__divsi3+0x42>
     c0a:	22ff      	movs	r2, #255	; 0xff
     c0c:	0209      	lsls	r1, r1, #8
     c0e:	ba12      	rev	r2, r2
     c10:	0c03      	lsrs	r3, r0, #16
     c12:	428b      	cmp	r3, r1
     c14:	d302      	bcc.n	c1c <__divsi3+0x38>
     c16:	1212      	asrs	r2, r2, #8
     c18:	0209      	lsls	r1, r1, #8
     c1a:	d065      	beq.n	ce8 <__divsi3+0x104>
     c1c:	0b03      	lsrs	r3, r0, #12
     c1e:	428b      	cmp	r3, r1
     c20:	d319      	bcc.n	c56 <__divsi3+0x72>
     c22:	e000      	b.n	c26 <__divsi3+0x42>
     c24:	0a09      	lsrs	r1, r1, #8
     c26:	0bc3      	lsrs	r3, r0, #15
     c28:	428b      	cmp	r3, r1
     c2a:	d301      	bcc.n	c30 <__divsi3+0x4c>
     c2c:	03cb      	lsls	r3, r1, #15
     c2e:	1ac0      	subs	r0, r0, r3
     c30:	4152      	adcs	r2, r2
     c32:	0b83      	lsrs	r3, r0, #14
     c34:	428b      	cmp	r3, r1
     c36:	d301      	bcc.n	c3c <__divsi3+0x58>
     c38:	038b      	lsls	r3, r1, #14
     c3a:	1ac0      	subs	r0, r0, r3
     c3c:	4152      	adcs	r2, r2
     c3e:	0b43      	lsrs	r3, r0, #13
     c40:	428b      	cmp	r3, r1
     c42:	d301      	bcc.n	c48 <__divsi3+0x64>
     c44:	034b      	lsls	r3, r1, #13
     c46:	1ac0      	subs	r0, r0, r3
     c48:	4152      	adcs	r2, r2
     c4a:	0b03      	lsrs	r3, r0, #12
     c4c:	428b      	cmp	r3, r1
     c4e:	d301      	bcc.n	c54 <__divsi3+0x70>
     c50:	030b      	lsls	r3, r1, #12
     c52:	1ac0      	subs	r0, r0, r3
     c54:	4152      	adcs	r2, r2
     c56:	0ac3      	lsrs	r3, r0, #11
     c58:	428b      	cmp	r3, r1
     c5a:	d301      	bcc.n	c60 <__divsi3+0x7c>
     c5c:	02cb      	lsls	r3, r1, #11
     c5e:	1ac0      	subs	r0, r0, r3
     c60:	4152      	adcs	r2, r2
     c62:	0a83      	lsrs	r3, r0, #10
     c64:	428b      	cmp	r3, r1
     c66:	d301      	bcc.n	c6c <__divsi3+0x88>
     c68:	028b      	lsls	r3, r1, #10
     c6a:	1ac0      	subs	r0, r0, r3
     c6c:	4152      	adcs	r2, r2
     c6e:	0a43      	lsrs	r3, r0, #9
     c70:	428b      	cmp	r3, r1
     c72:	d301      	bcc.n	c78 <__divsi3+0x94>
     c74:	024b      	lsls	r3, r1, #9
     c76:	1ac0      	subs	r0, r0, r3
     c78:	4152      	adcs	r2, r2
     c7a:	0a03      	lsrs	r3, r0, #8
     c7c:	428b      	cmp	r3, r1
     c7e:	d301      	bcc.n	c84 <__divsi3+0xa0>
     c80:	020b      	lsls	r3, r1, #8
     c82:	1ac0      	subs	r0, r0, r3
     c84:	4152      	adcs	r2, r2
     c86:	d2cd      	bcs.n	c24 <__divsi3+0x40>
     c88:	09c3      	lsrs	r3, r0, #7
     c8a:	428b      	cmp	r3, r1
     c8c:	d301      	bcc.n	c92 <__divsi3+0xae>
     c8e:	01cb      	lsls	r3, r1, #7
     c90:	1ac0      	subs	r0, r0, r3
     c92:	4152      	adcs	r2, r2
     c94:	0983      	lsrs	r3, r0, #6
     c96:	428b      	cmp	r3, r1
     c98:	d301      	bcc.n	c9e <__divsi3+0xba>
     c9a:	018b      	lsls	r3, r1, #6
     c9c:	1ac0      	subs	r0, r0, r3
     c9e:	4152      	adcs	r2, r2
     ca0:	0943      	lsrs	r3, r0, #5
     ca2:	428b      	cmp	r3, r1
     ca4:	d301      	bcc.n	caa <__divsi3+0xc6>
     ca6:	014b      	lsls	r3, r1, #5
     ca8:	1ac0      	subs	r0, r0, r3
     caa:	4152      	adcs	r2, r2
     cac:	0903      	lsrs	r3, r0, #4
     cae:	428b      	cmp	r3, r1
     cb0:	d301      	bcc.n	cb6 <__divsi3+0xd2>
     cb2:	010b      	lsls	r3, r1, #4
     cb4:	1ac0      	subs	r0, r0, r3
     cb6:	4152      	adcs	r2, r2
     cb8:	08c3      	lsrs	r3, r0, #3
     cba:	428b      	cmp	r3, r1
     cbc:	d301      	bcc.n	cc2 <__divsi3+0xde>
     cbe:	00cb      	lsls	r3, r1, #3
     cc0:	1ac0      	subs	r0, r0, r3
     cc2:	4152      	adcs	r2, r2
     cc4:	0883      	lsrs	r3, r0, #2
     cc6:	428b      	cmp	r3, r1
     cc8:	d301      	bcc.n	cce <__divsi3+0xea>
     cca:	008b      	lsls	r3, r1, #2
     ccc:	1ac0      	subs	r0, r0, r3
     cce:	4152      	adcs	r2, r2
     cd0:	0843      	lsrs	r3, r0, #1
     cd2:	428b      	cmp	r3, r1
     cd4:	d301      	bcc.n	cda <__divsi3+0xf6>
     cd6:	004b      	lsls	r3, r1, #1
     cd8:	1ac0      	subs	r0, r0, r3
     cda:	4152      	adcs	r2, r2
     cdc:	1a41      	subs	r1, r0, r1
     cde:	d200      	bcs.n	ce2 <__divsi3+0xfe>
     ce0:	4601      	mov	r1, r0
     ce2:	4152      	adcs	r2, r2
     ce4:	4610      	mov	r0, r2
     ce6:	4770      	bx	lr
     ce8:	e05d      	b.n	da6 <__divsi3+0x1c2>
     cea:	0fca      	lsrs	r2, r1, #31
     cec:	d000      	beq.n	cf0 <__divsi3+0x10c>
     cee:	4249      	negs	r1, r1
     cf0:	1003      	asrs	r3, r0, #32
     cf2:	d300      	bcc.n	cf6 <__divsi3+0x112>
     cf4:	4240      	negs	r0, r0
     cf6:	4053      	eors	r3, r2
     cf8:	2200      	movs	r2, #0
     cfa:	469c      	mov	ip, r3
     cfc:	0903      	lsrs	r3, r0, #4
     cfe:	428b      	cmp	r3, r1
     d00:	d32d      	bcc.n	d5e <__divsi3+0x17a>
     d02:	0a03      	lsrs	r3, r0, #8
     d04:	428b      	cmp	r3, r1
     d06:	d312      	bcc.n	d2e <__divsi3+0x14a>
     d08:	22fc      	movs	r2, #252	; 0xfc
     d0a:	0189      	lsls	r1, r1, #6
     d0c:	ba12      	rev	r2, r2
     d0e:	0a03      	lsrs	r3, r0, #8
     d10:	428b      	cmp	r3, r1
     d12:	d30c      	bcc.n	d2e <__divsi3+0x14a>
     d14:	0189      	lsls	r1, r1, #6
     d16:	1192      	asrs	r2, r2, #6
     d18:	428b      	cmp	r3, r1
     d1a:	d308      	bcc.n	d2e <__divsi3+0x14a>
     d1c:	0189      	lsls	r1, r1, #6
     d1e:	1192      	asrs	r2, r2, #6
     d20:	428b      	cmp	r3, r1
     d22:	d304      	bcc.n	d2e <__divsi3+0x14a>
     d24:	0189      	lsls	r1, r1, #6
     d26:	d03a      	beq.n	d9e <__divsi3+0x1ba>
     d28:	1192      	asrs	r2, r2, #6
     d2a:	e000      	b.n	d2e <__divsi3+0x14a>
     d2c:	0989      	lsrs	r1, r1, #6
     d2e:	09c3      	lsrs	r3, r0, #7
     d30:	428b      	cmp	r3, r1
     d32:	d301      	bcc.n	d38 <__divsi3+0x154>
     d34:	01cb      	lsls	r3, r1, #7
     d36:	1ac0      	subs	r0, r0, r3
     d38:	4152      	adcs	r2, r2
     d3a:	0983      	lsrs	r3, r0, #6
     d3c:	428b      	cmp	r3, r1
     d3e:	d301      	bcc.n	d44 <__divsi3+0x160>
     d40:	018b      	lsls	r3, r1, #6
     d42:	1ac0      	subs	r0, r0, r3
     d44:	4152      	adcs	r2, r2
     d46:	0943      	lsrs	r3, r0, #5
     d48:	428b      	cmp	r3, r1
     d4a:	d301      	bcc.n	d50 <__divsi3+0x16c>
     d4c:	014b      	lsls	r3, r1, #5
     d4e:	1ac0      	subs	r0, r0, r3
     d50:	4152      	adcs	r2, r2
     d52:	0903      	lsrs	r3, r0, #4
     d54:	428b      	cmp	r3, r1
     d56:	d301      	bcc.n	d5c <__divsi3+0x178>
     d58:	010b      	lsls	r3, r1, #4
     d5a:	1ac0      	subs	r0, r0, r3
     d5c:	4152      	adcs	r2, r2
     d5e:	08c3      	lsrs	r3, r0, #3
     d60:	428b      	cmp	r3, r1
     d62:	d301      	bcc.n	d68 <__divsi3+0x184>
     d64:	00cb      	lsls	r3, r1, #3
     d66:	1ac0      	subs	r0, r0, r3
     d68:	4152      	adcs	r2, r2
     d6a:	0883      	lsrs	r3, r0, #2
     d6c:	428b      	cmp	r3, r1
     d6e:	d301      	bcc.n	d74 <__divsi3+0x190>
     d70:	008b      	lsls	r3, r1, #2
     d72:	1ac0      	subs	r0, r0, r3
     d74:	4152      	adcs	r2, r2
     d76:	d2d9      	bcs.n	d2c <__divsi3+0x148>
     d78:	0843      	lsrs	r3, r0, #1
     d7a:	428b      	cmp	r3, r1
     d7c:	d301      	bcc.n	d82 <__divsi3+0x19e>
     d7e:	004b      	lsls	r3, r1, #1
     d80:	1ac0      	subs	r0, r0, r3
     d82:	4152      	adcs	r2, r2
     d84:	1a41      	subs	r1, r0, r1
     d86:	d200      	bcs.n	d8a <__divsi3+0x1a6>
     d88:	4601      	mov	r1, r0
     d8a:	4663      	mov	r3, ip
     d8c:	4152      	adcs	r2, r2
     d8e:	105b      	asrs	r3, r3, #1
     d90:	4610      	mov	r0, r2
     d92:	d301      	bcc.n	d98 <__divsi3+0x1b4>
     d94:	4240      	negs	r0, r0
     d96:	2b00      	cmp	r3, #0
     d98:	d500      	bpl.n	d9c <__divsi3+0x1b8>
     d9a:	4249      	negs	r1, r1
     d9c:	4770      	bx	lr
     d9e:	4663      	mov	r3, ip
     da0:	105b      	asrs	r3, r3, #1
     da2:	d300      	bcc.n	da6 <__divsi3+0x1c2>
     da4:	4240      	negs	r0, r0
     da6:	b501      	push	{r0, lr}
     da8:	2000      	movs	r0, #0
     daa:	f000 f805 	bl	db8 <__aeabi_idiv0>
     dae:	bd02      	pop	{r1, pc}

00000db0 <__aeabi_idivmod>:
     db0:	2900      	cmp	r1, #0
     db2:	d0f8      	beq.n	da6 <__divsi3+0x1c2>
     db4:	e716      	b.n	be4 <__divsi3>
     db6:	4770      	bx	lr

00000db8 <__aeabi_idiv0>:
     db8:	4770      	bx	lr
     dba:	46c0      	nop			; (mov r8, r8)

00000dbc <__aeabi_lmul>:
     dbc:	b5f0      	push	{r4, r5, r6, r7, lr}
     dbe:	46ce      	mov	lr, r9
     dc0:	4647      	mov	r7, r8
     dc2:	0415      	lsls	r5, r2, #16
     dc4:	0c2d      	lsrs	r5, r5, #16
     dc6:	002e      	movs	r6, r5
     dc8:	b580      	push	{r7, lr}
     dca:	0407      	lsls	r7, r0, #16
     dcc:	0c14      	lsrs	r4, r2, #16
     dce:	0c3f      	lsrs	r7, r7, #16
     dd0:	4699      	mov	r9, r3
     dd2:	0c03      	lsrs	r3, r0, #16
     dd4:	437e      	muls	r6, r7
     dd6:	435d      	muls	r5, r3
     dd8:	4367      	muls	r7, r4
     dda:	4363      	muls	r3, r4
     ddc:	197f      	adds	r7, r7, r5
     dde:	0c34      	lsrs	r4, r6, #16
     de0:	19e4      	adds	r4, r4, r7
     de2:	469c      	mov	ip, r3
     de4:	42a5      	cmp	r5, r4
     de6:	d903      	bls.n	df0 <__aeabi_lmul+0x34>
     de8:	2380      	movs	r3, #128	; 0x80
     dea:	025b      	lsls	r3, r3, #9
     dec:	4698      	mov	r8, r3
     dee:	44c4      	add	ip, r8
     df0:	464b      	mov	r3, r9
     df2:	4351      	muls	r1, r2
     df4:	4343      	muls	r3, r0
     df6:	0436      	lsls	r6, r6, #16
     df8:	0c36      	lsrs	r6, r6, #16
     dfa:	0c25      	lsrs	r5, r4, #16
     dfc:	0424      	lsls	r4, r4, #16
     dfe:	4465      	add	r5, ip
     e00:	19a4      	adds	r4, r4, r6
     e02:	1859      	adds	r1, r3, r1
     e04:	1949      	adds	r1, r1, r5
     e06:	0020      	movs	r0, r4
     e08:	bc0c      	pop	{r2, r3}
     e0a:	4690      	mov	r8, r2
     e0c:	4699      	mov	r9, r3
     e0e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000e10 <__libc_init_array>:
     e10:	b570      	push	{r4, r5, r6, lr}
     e12:	4e0d      	ldr	r6, [pc, #52]	; (e48 <__libc_init_array+0x38>)
     e14:	4d0d      	ldr	r5, [pc, #52]	; (e4c <__libc_init_array+0x3c>)
     e16:	2400      	movs	r4, #0
     e18:	1bad      	subs	r5, r5, r6
     e1a:	10ad      	asrs	r5, r5, #2
     e1c:	d005      	beq.n	e2a <__libc_init_array+0x1a>
     e1e:	00a3      	lsls	r3, r4, #2
     e20:	58f3      	ldr	r3, [r6, r3]
     e22:	3401      	adds	r4, #1
     e24:	4798      	blx	r3
     e26:	42a5      	cmp	r5, r4
     e28:	d1f9      	bne.n	e1e <__libc_init_array+0xe>
     e2a:	f000 f925 	bl	1078 <_init>
     e2e:	4e08      	ldr	r6, [pc, #32]	; (e50 <__libc_init_array+0x40>)
     e30:	4d08      	ldr	r5, [pc, #32]	; (e54 <__libc_init_array+0x44>)
     e32:	2400      	movs	r4, #0
     e34:	1bad      	subs	r5, r5, r6
     e36:	10ad      	asrs	r5, r5, #2
     e38:	d005      	beq.n	e46 <__libc_init_array+0x36>
     e3a:	00a3      	lsls	r3, r4, #2
     e3c:	58f3      	ldr	r3, [r6, r3]
     e3e:	3401      	adds	r4, #1
     e40:	4798      	blx	r3
     e42:	42a5      	cmp	r5, r4
     e44:	d1f9      	bne.n	e3a <__libc_init_array+0x2a>
     e46:	bd70      	pop	{r4, r5, r6, pc}
     e48:	00001084 	.word	0x00001084
     e4c:	00001084 	.word	0x00001084
     e50:	00001084 	.word	0x00001084
     e54:	0000108c 	.word	0x0000108c

00000e58 <memset>:
     e58:	b5f0      	push	{r4, r5, r6, r7, lr}
     e5a:	0783      	lsls	r3, r0, #30
     e5c:	d043      	beq.n	ee6 <memset+0x8e>
     e5e:	1e54      	subs	r4, r2, #1
     e60:	2a00      	cmp	r2, #0
     e62:	d03f      	beq.n	ee4 <memset+0x8c>
     e64:	b2ce      	uxtb	r6, r1
     e66:	0002      	movs	r2, r0
     e68:	2503      	movs	r5, #3
     e6a:	e002      	b.n	e72 <memset+0x1a>
     e6c:	001a      	movs	r2, r3
     e6e:	3c01      	subs	r4, #1
     e70:	d338      	bcc.n	ee4 <memset+0x8c>
     e72:	1c53      	adds	r3, r2, #1
     e74:	7016      	strb	r6, [r2, #0]
     e76:	422b      	tst	r3, r5
     e78:	d1f8      	bne.n	e6c <memset+0x14>
     e7a:	2c03      	cmp	r4, #3
     e7c:	d92a      	bls.n	ed4 <memset+0x7c>
     e7e:	22ff      	movs	r2, #255	; 0xff
     e80:	400a      	ands	r2, r1
     e82:	0215      	lsls	r5, r2, #8
     e84:	4315      	orrs	r5, r2
     e86:	042a      	lsls	r2, r5, #16
     e88:	4315      	orrs	r5, r2
     e8a:	2c0f      	cmp	r4, #15
     e8c:	d914      	bls.n	eb8 <memset+0x60>
     e8e:	0027      	movs	r7, r4
     e90:	001a      	movs	r2, r3
     e92:	3f10      	subs	r7, #16
     e94:	093e      	lsrs	r6, r7, #4
     e96:	3601      	adds	r6, #1
     e98:	0136      	lsls	r6, r6, #4
     e9a:	199e      	adds	r6, r3, r6
     e9c:	6015      	str	r5, [r2, #0]
     e9e:	6055      	str	r5, [r2, #4]
     ea0:	6095      	str	r5, [r2, #8]
     ea2:	60d5      	str	r5, [r2, #12]
     ea4:	3210      	adds	r2, #16
     ea6:	4296      	cmp	r6, r2
     ea8:	d1f8      	bne.n	e9c <memset+0x44>
     eaa:	220f      	movs	r2, #15
     eac:	4397      	bics	r7, r2
     eae:	3710      	adds	r7, #16
     eb0:	19db      	adds	r3, r3, r7
     eb2:	4014      	ands	r4, r2
     eb4:	2c03      	cmp	r4, #3
     eb6:	d90d      	bls.n	ed4 <memset+0x7c>
     eb8:	001a      	movs	r2, r3
     eba:	1f27      	subs	r7, r4, #4
     ebc:	08be      	lsrs	r6, r7, #2
     ebe:	3601      	adds	r6, #1
     ec0:	00b6      	lsls	r6, r6, #2
     ec2:	199e      	adds	r6, r3, r6
     ec4:	c220      	stmia	r2!, {r5}
     ec6:	42b2      	cmp	r2, r6
     ec8:	d1fc      	bne.n	ec4 <memset+0x6c>
     eca:	2203      	movs	r2, #3
     ecc:	4397      	bics	r7, r2
     ece:	3704      	adds	r7, #4
     ed0:	19db      	adds	r3, r3, r7
     ed2:	4014      	ands	r4, r2
     ed4:	2c00      	cmp	r4, #0
     ed6:	d005      	beq.n	ee4 <memset+0x8c>
     ed8:	b2c9      	uxtb	r1, r1
     eda:	191c      	adds	r4, r3, r4
     edc:	7019      	strb	r1, [r3, #0]
     ede:	3301      	adds	r3, #1
     ee0:	429c      	cmp	r4, r3
     ee2:	d1fb      	bne.n	edc <memset+0x84>
     ee4:	bdf0      	pop	{r4, r5, r6, r7, pc}
     ee6:	0014      	movs	r4, r2
     ee8:	0003      	movs	r3, r0
     eea:	e7c6      	b.n	e7a <memset+0x22>

00000eec <register_fini>:
     eec:	4b03      	ldr	r3, [pc, #12]	; (efc <register_fini+0x10>)
     eee:	b510      	push	{r4, lr}
     ef0:	2b00      	cmp	r3, #0
     ef2:	d002      	beq.n	efa <register_fini+0xe>
     ef4:	4802      	ldr	r0, [pc, #8]	; (f00 <register_fini+0x14>)
     ef6:	f000 f805 	bl	f04 <atexit>
     efa:	bd10      	pop	{r4, pc}
     efc:	00000000 	.word	0x00000000
     f00:	00000f15 	.word	0x00000f15

00000f04 <atexit>:
     f04:	b510      	push	{r4, lr}
     f06:	0001      	movs	r1, r0
     f08:	2300      	movs	r3, #0
     f0a:	2200      	movs	r2, #0
     f0c:	2000      	movs	r0, #0
     f0e:	f000 f81f 	bl	f50 <__register_exitproc>
     f12:	bd10      	pop	{r4, pc}

00000f14 <__libc_fini_array>:
     f14:	b570      	push	{r4, r5, r6, lr}
     f16:	4b09      	ldr	r3, [pc, #36]	; (f3c <__libc_fini_array+0x28>)
     f18:	4c09      	ldr	r4, [pc, #36]	; (f40 <__libc_fini_array+0x2c>)
     f1a:	1ae4      	subs	r4, r4, r3
     f1c:	10a4      	asrs	r4, r4, #2
     f1e:	d009      	beq.n	f34 <__libc_fini_array+0x20>
     f20:	4a08      	ldr	r2, [pc, #32]	; (f44 <__libc_fini_array+0x30>)
     f22:	18a5      	adds	r5, r4, r2
     f24:	00ad      	lsls	r5, r5, #2
     f26:	18ed      	adds	r5, r5, r3
     f28:	682b      	ldr	r3, [r5, #0]
     f2a:	3c01      	subs	r4, #1
     f2c:	4798      	blx	r3
     f2e:	3d04      	subs	r5, #4
     f30:	2c00      	cmp	r4, #0
     f32:	d1f9      	bne.n	f28 <__libc_fini_array+0x14>
     f34:	f000 f8aa 	bl	108c <_fini>
     f38:	bd70      	pop	{r4, r5, r6, pc}
     f3a:	46c0      	nop			; (mov r8, r8)
     f3c:	00001098 	.word	0x00001098
     f40:	0000109c 	.word	0x0000109c
     f44:	3fffffff 	.word	0x3fffffff

00000f48 <__retarget_lock_acquire_recursive>:
     f48:	4770      	bx	lr
     f4a:	46c0      	nop			; (mov r8, r8)

00000f4c <__retarget_lock_release_recursive>:
     f4c:	4770      	bx	lr
     f4e:	46c0      	nop			; (mov r8, r8)

00000f50 <__register_exitproc>:
     f50:	b5f0      	push	{r4, r5, r6, r7, lr}
     f52:	464e      	mov	r6, r9
     f54:	4645      	mov	r5, r8
     f56:	46de      	mov	lr, fp
     f58:	4657      	mov	r7, sl
     f5a:	b5e0      	push	{r5, r6, r7, lr}
     f5c:	4d36      	ldr	r5, [pc, #216]	; (1038 <__register_exitproc+0xe8>)
     f5e:	b083      	sub	sp, #12
     f60:	0006      	movs	r6, r0
     f62:	6828      	ldr	r0, [r5, #0]
     f64:	4698      	mov	r8, r3
     f66:	000f      	movs	r7, r1
     f68:	4691      	mov	r9, r2
     f6a:	f7ff ffed 	bl	f48 <__retarget_lock_acquire_recursive>
     f6e:	4b33      	ldr	r3, [pc, #204]	; (103c <__register_exitproc+0xec>)
     f70:	681c      	ldr	r4, [r3, #0]
     f72:	23a4      	movs	r3, #164	; 0xa4
     f74:	005b      	lsls	r3, r3, #1
     f76:	58e0      	ldr	r0, [r4, r3]
     f78:	2800      	cmp	r0, #0
     f7a:	d052      	beq.n	1022 <__register_exitproc+0xd2>
     f7c:	6843      	ldr	r3, [r0, #4]
     f7e:	2b1f      	cmp	r3, #31
     f80:	dc13      	bgt.n	faa <__register_exitproc+0x5a>
     f82:	1c5a      	adds	r2, r3, #1
     f84:	9201      	str	r2, [sp, #4]
     f86:	2e00      	cmp	r6, #0
     f88:	d128      	bne.n	fdc <__register_exitproc+0x8c>
     f8a:	9a01      	ldr	r2, [sp, #4]
     f8c:	3302      	adds	r3, #2
     f8e:	009b      	lsls	r3, r3, #2
     f90:	6042      	str	r2, [r0, #4]
     f92:	501f      	str	r7, [r3, r0]
     f94:	6828      	ldr	r0, [r5, #0]
     f96:	f7ff ffd9 	bl	f4c <__retarget_lock_release_recursive>
     f9a:	2000      	movs	r0, #0
     f9c:	b003      	add	sp, #12
     f9e:	bc3c      	pop	{r2, r3, r4, r5}
     fa0:	4690      	mov	r8, r2
     fa2:	4699      	mov	r9, r3
     fa4:	46a2      	mov	sl, r4
     fa6:	46ab      	mov	fp, r5
     fa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     faa:	4b25      	ldr	r3, [pc, #148]	; (1040 <__register_exitproc+0xf0>)
     fac:	2b00      	cmp	r3, #0
     fae:	d03d      	beq.n	102c <__register_exitproc+0xdc>
     fb0:	20c8      	movs	r0, #200	; 0xc8
     fb2:	0040      	lsls	r0, r0, #1
     fb4:	e000      	b.n	fb8 <__register_exitproc+0x68>
     fb6:	bf00      	nop
     fb8:	2800      	cmp	r0, #0
     fba:	d037      	beq.n	102c <__register_exitproc+0xdc>
     fbc:	22a4      	movs	r2, #164	; 0xa4
     fbe:	2300      	movs	r3, #0
     fc0:	0052      	lsls	r2, r2, #1
     fc2:	58a1      	ldr	r1, [r4, r2]
     fc4:	6043      	str	r3, [r0, #4]
     fc6:	6001      	str	r1, [r0, #0]
     fc8:	50a0      	str	r0, [r4, r2]
     fca:	3240      	adds	r2, #64	; 0x40
     fcc:	5083      	str	r3, [r0, r2]
     fce:	3204      	adds	r2, #4
     fd0:	5083      	str	r3, [r0, r2]
     fd2:	3301      	adds	r3, #1
     fd4:	9301      	str	r3, [sp, #4]
     fd6:	2300      	movs	r3, #0
     fd8:	2e00      	cmp	r6, #0
     fda:	d0d6      	beq.n	f8a <__register_exitproc+0x3a>
     fdc:	009a      	lsls	r2, r3, #2
     fde:	4692      	mov	sl, r2
     fe0:	4482      	add	sl, r0
     fe2:	464a      	mov	r2, r9
     fe4:	2188      	movs	r1, #136	; 0x88
     fe6:	4654      	mov	r4, sl
     fe8:	5062      	str	r2, [r4, r1]
     fea:	22c4      	movs	r2, #196	; 0xc4
     fec:	0052      	lsls	r2, r2, #1
     fee:	4691      	mov	r9, r2
     ff0:	4481      	add	r9, r0
     ff2:	464a      	mov	r2, r9
     ff4:	3987      	subs	r1, #135	; 0x87
     ff6:	4099      	lsls	r1, r3
     ff8:	6812      	ldr	r2, [r2, #0]
     ffa:	468b      	mov	fp, r1
     ffc:	430a      	orrs	r2, r1
     ffe:	4694      	mov	ip, r2
    1000:	464a      	mov	r2, r9
    1002:	4661      	mov	r1, ip
    1004:	6011      	str	r1, [r2, #0]
    1006:	2284      	movs	r2, #132	; 0x84
    1008:	4641      	mov	r1, r8
    100a:	0052      	lsls	r2, r2, #1
    100c:	50a1      	str	r1, [r4, r2]
    100e:	2e02      	cmp	r6, #2
    1010:	d1bb      	bne.n	f8a <__register_exitproc+0x3a>
    1012:	0002      	movs	r2, r0
    1014:	465c      	mov	r4, fp
    1016:	328d      	adds	r2, #141	; 0x8d
    1018:	32ff      	adds	r2, #255	; 0xff
    101a:	6811      	ldr	r1, [r2, #0]
    101c:	430c      	orrs	r4, r1
    101e:	6014      	str	r4, [r2, #0]
    1020:	e7b3      	b.n	f8a <__register_exitproc+0x3a>
    1022:	0020      	movs	r0, r4
    1024:	304d      	adds	r0, #77	; 0x4d
    1026:	30ff      	adds	r0, #255	; 0xff
    1028:	50e0      	str	r0, [r4, r3]
    102a:	e7a7      	b.n	f7c <__register_exitproc+0x2c>
    102c:	6828      	ldr	r0, [r5, #0]
    102e:	f7ff ff8d 	bl	f4c <__retarget_lock_release_recursive>
    1032:	2001      	movs	r0, #1
    1034:	4240      	negs	r0, r0
    1036:	e7b1      	b.n	f9c <__register_exitproc+0x4c>
    1038:	20000470 	.word	0x20000470
    103c:	00001074 	.word	0x00001074
    1040:	00000000 	.word	0x00000000
    1044:	000002ac 	.word	0x000002ac
    1048:	000002dc 	.word	0x000002dc
    104c:	0000030c 	.word	0x0000030c
    1050:	0000033c 	.word	0x0000033c
    1054:	0000036c 	.word	0x0000036c
    1058:	0000039c 	.word	0x0000039c
    105c:	000002d0 	.word	0x000002d0
    1060:	00000300 	.word	0x00000300
    1064:	00000330 	.word	0x00000330
    1068:	00000360 	.word	0x00000360
    106c:	00000390 	.word	0x00000390
    1070:	000003c0 	.word	0x000003c0

00001074 <_global_impure_ptr>:
    1074:	20000048                                H.. 

00001078 <_init>:
    1078:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    107a:	46c0      	nop			; (mov r8, r8)
    107c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    107e:	bc08      	pop	{r3}
    1080:	469e      	mov	lr, r3
    1082:	4770      	bx	lr

00001084 <__init_array_start>:
    1084:	00000eed 	.word	0x00000eed

00001088 <__frame_dummy_init_array_entry>:
    1088:	000000dd                                ....

0000108c <_fini>:
    108c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    108e:	46c0      	nop			; (mov r8, r8)
    1090:	bcf8      	pop	{r3, r4, r5, r6, r7}
    1092:	bc08      	pop	{r3}
    1094:	469e      	mov	lr, r3
    1096:	4770      	bx	lr

00001098 <__fini_array_start>:
    1098:	000000b5 	.word	0x000000b5
